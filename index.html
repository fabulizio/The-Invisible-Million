<script>
(() => {
  const BACKEND_URL = "https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev";

  // DOM elements
  const canvas = document.getElementById('gridCanvas');
  const ctx = canvas.getContext('2d');
  const frame = document.getElementById('frame');
  const coordsDisplay = document.querySelector('footer .coords');
  const colorSelect = document.getElementById('colorSelect');
  const donateBtn = document.getElementById('donateBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const zoomDisplay = document.getElementById('zoomDisplay');

  // Grid settings
  const GRID_SIZE = 1100;
  const CELL_SIZE = 30;
  let MIN_ZOOM = 1; // will be calculated
  const MAX_ZOOM = 3;
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;

  // State
  let isDragging = false;
  let dragStart = {x: 0, y: 0};
  let offsetStart = {x: 0, y: 0};
  let selectedColor = colorSelect.value;
  let coloredCells = {}; // { "x,y": color }
  let redrawPending = false;
  let touchStart = null;

  // Dedicated grid cursor
  let gridCursor = {x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2)};

  // Helpers
  function setCanvasSize() {
    const rect = frame.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    // Calculate minimal zoom to fit whole grid
    MIN_ZOOM = Math.min(
      canvas.width / (GRID_SIZE * CELL_SIZE),
      canvas.height / (GRID_SIZE * CELL_SIZE)
    );
    if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
    clampOffset();
    drawGrid();
  }

  function drawGrid() {
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, width, height);

    const scaledCellSize = CELL_SIZE * zoom;
    const startCol = Math.floor(-offsetX / scaledCellSize);
    const startRow = Math.floor(-offsetY / scaledCellSize);
    const visibleCols = Math.ceil(width / scaledCellSize) + 1;
    const visibleRows = Math.ceil(height / scaledCellSize) + 1;

    // Draw grid lines
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    for(let c = startCol; c <= startCol + visibleCols; c++) {
      if (c < 0 || c >= GRID_SIZE) continue;
      const x = offsetX + c * scaledCellSize;
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, height);
      ctx.stroke();
    }
    for(let r = startRow; r <= startRow + visibleRows; r++) {
      if (r < 0 || r >= GRID_SIZE) continue;
      const y = offsetY + r * scaledCellSize;
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(width, y + 0.5);
      ctx.stroke();
    }

    // Draw colored cells
    for (const key in coloredCells) {
      const [x, y] = key.split(',').map(Number);
      if (
        x >= startCol && x <= startCol + visibleCols &&
        y >= startRow && y <= startRow + visibleRows
      ) {
        const cellX = offsetX + x * scaledCellSize;
        const cellY = offsetY + y * scaledCellSize;
        ctx.fillStyle = coloredCells[key];
        ctx.fillRect(cellX + 1, cellY + 1, scaledCellSize - 2, scaledCellSize - 2);
      }
    }

    // Draw grid cursor (target pointer)
    const cursorX = offsetX + gridCursor.x * scaledCellSize + scaledCellSize/2;
    const cursorY = offsetY + gridCursor.y * scaledCellSize + scaledCellSize/2;
    ctx.save();
    ctx.beginPath();
    ctx.arc(cursorX, cursorY, scaledCellSize * 0.4, 0, Math.PI * 2);
    ctx.strokeStyle = '#FF0070';
    ctx.lineWidth = Math.max(2, scaledCellSize * 0.08);
    ctx.stroke();

    // Crosshair
    ctx.beginPath();
    ctx.moveTo(cursorX - scaledCellSize*0.25, cursorY);
    ctx.lineTo(cursorX + scaledCellSize*0.25, cursorY);
    ctx.moveTo(cursorX, cursorY - scaledCellSize*0.25);
    ctx.lineTo(cursorX, cursorY + scaledCellSize*0.25);
    ctx.strokeStyle = '#FF0070';
    ctx.lineWidth = Math.max(2, scaledCellSize * 0.04);
    ctx.stroke();
    ctx.restore();

    // Highlight selected (cursor) cell
    const highlightX = offsetX + gridCursor.x * scaledCellSize;
    const highlightY = offsetY + gridCursor.y * scaledCellSize;
    ctx.fillStyle = selectedColor + '33';
    ctx.fillRect(highlightX + 1, highlightY + 1, scaledCellSize - 2, scaledCellSize - 2);
  }

  function requestRedraw() {
    if (redrawPending) return;
    redrawPending = true;
    requestAnimationFrame(() => {
      drawGrid();
      redrawPending = false;
    });
  }

  function updateCoordsDisplay(cellX, cellY) {
    coordsDisplay.textContent = `X: ${cellX}, Y: ${cellY}`;
  }

  function clampOffset() {
    const scaledCellSize = CELL_SIZE * zoom;
    const maxOffsetX = 0;
    const maxOffsetY = 0;
    const minOffsetX = Math.min(canvas.width - GRID_SIZE * scaledCellSize, 0);
    const minOffsetY = Math.min(canvas.height - GRID_SIZE * scaledCellSize, 0);

    if (minOffsetX > maxOffsetX) {
      offsetX = (canvas.width - GRID_SIZE * scaledCellSize) / 2;
    } else {
      offsetX = Math.min(maxOffsetX, Math.max(minOffsetX, offsetX));
    }
    if (minOffsetY > maxOffsetY) {
      offsetY = (canvas.height - GRID_SIZE * scaledCellSize) / 2;
    } else {
      offsetY = Math.min(maxOffsetY, Math.max(minOffsetY, offsetY));
    }
  }

  // Ensures the grid cursor cell is fully visible in the frame
  function ensureCellVisible(cellX, cellY) {
    const scaledCellSize = CELL_SIZE * zoom;
    const cellLeft = offsetX + cellX * scaledCellSize;
    const cellRight = cellLeft + scaledCellSize;
    const cellTop = offsetY + cellY * scaledCellSize;
    const cellBottom = cellTop + scaledCellSize;

    let changed = false;

    if (cellLeft < 0) {
      offsetX += -cellLeft;
      changed = true;
    }
    if (cellRight > canvas.width) {
      offsetX -= cellRight - canvas.width;
      changed = true;
    }
    if (cellTop < 0) {
      offsetY += -cellTop;
      changed = true;
    }
    if (cellBottom > canvas.height) {
      offsetY -= cellBottom - canvas.height;
      changed = true;
    }
    if (changed) {
      clampOffset();
      requestRedraw();
    }
  }

  function setZoom(newZoom, centerX, centerY) {
    const oldZoom = zoom;
    zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
    if (centerX === undefined || centerY === undefined) {
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
    }
    offsetX = centerX - ((centerX - offsetX) * (zoom / oldZoom));
    offsetY = centerY - ((centerY - offsetY) * (zoom / oldZoom));
    clampOffset();
    zoomDisplay.textContent = Math.round(zoom * 100) + '%';
    requestRedraw();
  }

  // Backend communication
  function sendCellColor(x, y, color) {
    fetch(`${BACKEND_URL}/cell`, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({x, y, color})
    })
    .then(res => res.json())
    .then(data => {
      // Optionally handle response
    })
    .catch(err => {
      console.error('Backend error:', err);
    });
  }

  function fetchGridState() {
    fetch(`${BACKEND_URL}/grid`)
      .then(res => res.json())
      .then(data => {
        if (data && data.cells) {
          coloredCells = {};
          data.cells.forEach(cell => {
            coloredCells[`${cell.x},${cell.y}`] = cell.color;
          });
          requestRedraw();
        }
      })
      .catch(err => {
        console.error('Failed to fetch grid state:', err);
      });
  }

  // Wheel zoom
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomStep = 1.1;
    if(e.deltaY < 0) setZoom(zoom * zoomStep, e.offsetX, e.offsetY);
    else setZoom(zoom / zoomStep, e.offsetX, e.offsetY);
  }, {passive: false});

  // Mouse drag pan
  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart.x = e.clientX;
    dragStart.y = e.clientY;
    offsetStart.x = offsetX;
    offsetStart.y = offsetY;
    canvas.setPointerCapture(e.pointerId || 0);
  });
  window.addEventListener('mouseup', () => { isDragging = false; });
  window.addEventListener('mousemove', (e) => {
    if(!isDragging) return;
    offsetX = offsetStart.x + (e.clientX - dragStart.x);
    offsetY = offsetStart.y + (e.clientY - dragStart.y);
    clampOffset();
    requestRedraw();
  });

  // Move grid cursor with mouse click
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const cell = pixelToCell(mouseX, mouseY);
    gridCursor.x = Math.max(0, Math.min(GRID_SIZE - 1, cell.x));
    gridCursor.y = Math.max(0, Math.min(GRID_SIZE - 1, cell.y));
    updateCoordsDisplay(gridCursor.x, gridCursor.y);
    ensureCellVisible(gridCursor.x, gridCursor.y);
    requestRedraw();
  });

  // Color cell at cursor with Enter/Space
  frame.addEventListener('keydown', (e) => {
    let moved = false;
    switch(e.key) {
      case 'ArrowLeft':
        if (gridCursor.x > 0) { gridCursor.x--; moved = true; }
        e.preventDefault(); break;
      case 'ArrowRight':
        if (gridCursor.x < GRID_SIZE - 1) { gridCursor.x++; moved = true; }
        e.preventDefault(); break;
      case 'ArrowUp':
        if (gridCursor.y > 0) { gridCursor.y--; moved = true; }
        e.preventDefault(); break;
      case 'ArrowDown':
        if (gridCursor.y < GRID_SIZE - 1) { gridCursor.y++; moved = true; }
        e.preventDefault(); break;
      case '+': case '=':
        setZoom(zoom * 1.1);
        e.preventDefault(); break;
      case '-':
        setZoom(zoom / 1.1);
        e.preventDefault(); break;
      case 'Enter':
      case ' ': // Space
        coloredCells[`${gridCursor.x},${gridCursor.y}`] = selectedColor;
        sendCellColor(gridCursor.x, gridCursor.y, selectedColor);
        requestRedraw();
        e.preventDefault(); break;
    }
    if (moved) {
      updateCoordsDisplay(gridCursor.x, gridCursor.y);
      ensureCellVisible(gridCursor.x, gridCursor.y);
      requestRedraw();
    }
  });

  // Mouse move: update cursor display, but don't move gridCursor
  canvas.addEventListener('mousemove', (e) => {
    if(isDragging) return;
    if (redrawPending) return;
    redrawPending = true;
    requestAnimationFrame(() => {
      updateCoordsDisplay(gridCursor.x, gridCursor.y);
      redrawPending = false;
    });
  });

  // Touch support for pan
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      touchStart = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY,
        offsetX,
        offsetY
      };
    }
  }, {passive:true});
  canvas.addEventListener('touchmove', (e) => {
    if (!touchStart || e.touches.length !== 1) return;
    const dx = e.touches[0].clientX - touchStart.x;
    const dy = e.touches[0].clientY - touchStart.y;
    offsetX = touchStart.offsetX + dx;
    offsetY = touchStart.offsetY + dy;
    clampOffset();
    requestRedraw();
  }, {passive:true});
  canvas.addEventListener('touchend', () => { touchStart = null; });

  // Donate button
  donateBtn.addEventListener('click', () => {
    alert('Thank you for your intention to donate! (Functionality to be implemented)');
    donateBtn.focus();
  });

  // Color selector
  colorSelect.addEventListener('change', (e) => {
    selectedColor = e.target.value;
    requestRedraw();
  });

  // Zoom buttons
  zoomInBtn.addEventListener('click', () => setZoom(zoom * 1.1));
  zoomOutBtn.addEventListener('click', () => setZoom(zoom / 1.1));

  // Focus frame for keyboard input
  window.addEventListener('load', () => {
    setCanvasSize();
    frame.focus();
    zoomDisplay.textContent = Math.round(zoom * 100) + '%';
    fetchGridState();
    updateCoordsDisplay(gridCursor.x, gridCursor.y);
    ensureCellVisible(gridCursor.x, gridCursor.y);
    requestRedraw();
  });
  window.addEventListener('resize', setCanvasSize);
  frame.addEventListener('click', () => { frame.focus(); });

})();
</script>
