<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zoomable Grid with Color Picker</title>
<style>
  body, html { margin:0; height:100%; overflow:hidden; font-family: Arial, sans-serif; }
  #frame {
    position: relative;
    width: 100vw; height: 100vh;
    background: #eee;
    overflow: hidden;
  }
  #grid {
    position: absolute;
    top:0; left:0;
    transform-origin: top left;
    cursor: pointer;
  }
  .cell {
    box-sizing: border-box;
    border: 1px solid #ccc;
    width: 20px;
    height: 20px;
    float: left;
    background: white;
  }
  #minimap {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 200px;
    height: 200px;
    background: white;
    border: 1px solid black;
    opacity: 0.8;
    z-index: 1000;
    overflow: hidden;
  }
  #colorPickerPopup {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 2px solid #333;
    padding: 15px;
    box-shadow: 0 0 10px #000a;
    display: none;
    z-index: 2000;
  }
  #colorPickerPopup input[type=color] {
    width: 100px;
    height: 40px;
    border:none;
    cursor:pointer;
  }
  #colorPickerPopup button {
    margin-left: 10px;
    padding: 6px 12px;
  }
</style>
</head>
<body>
<div id="frame">
  <div id="grid"></div>
  <canvas id="minimap"></canvas>
</div>

<!-- Color picker popup -->
<div id="colorPickerPopup">
  <label for="colorPicker">Choose color:</label>
  <input type="color" id="colorPicker" value="#ff0000" />
  <button id="colorConfirmBtn">OK</button>
  <button id="colorCancelBtn">Cancel</button>
</div>

<script>
  // Constants
  const GRID_SIZE = 1000; // 1000x1000 grid
  const CELL_SIZE = 20;   // px
  let scale = 1;
  let offsetX = 0;
  let offsetY = 0;

  // Grid data: store colors for squares (key: "x_y" => color string)
  const coloredSquares = {};

  // Selected cell for coloring
  let selectedCell = null;

  // DOM refs
  const frame = document.getElementById('frame');
  const grid = document.getElementById('grid');
  const minimap = document.getElementById('minimap');
  const colorPopup = document.getElementById('colorPickerPopup');
  const colorPicker = document.getElementById('colorPicker');
  const colorConfirmBtn = document.getElementById('colorConfirmBtn');
  const colorCancelBtn = document.getElementById('colorCancelBtn');

  // Initialize grid container size
  grid.style.width = (GRID_SIZE * CELL_SIZE) + 'px';
  grid.style.height = (GRID_SIZE * CELL_SIZE) + 'px';

  // Create canvas context for minimap
  const minimapCtx = minimap.getContext('2d');

  // We'll not create 1 million divs â€” too heavy.
  // Instead we will use a virtual approach for visible part.

  // For demo, let's create a smaller grid (50x50) with cells as divs for interaction,
  // but your full grid would need canvas or optimized approach for performance.

  const VISIBLE_CELLS = 50;
  const visibleGridSizePx = VISIBLE_CELLS * CELL_SIZE;

  // We'll create VISIBLE_CELLS^2 div cells inside grid container,
  // and update their positions on pan/zoom.

  // Generate visible cells pool
  const visibleCells = [];
  for(let i=0; i<VISIBLE_CELLS*VISIBLE_CELLS; i++) {
    const cell = document.createElement('div');
    cell.classList.add('cell');
    grid.appendChild(cell);
    visibleCells.push(cell);
  }

  // Convert page coords to grid coords (x,y of cell)
  function pageToGrid(x, y) {
    const gx = Math.floor((x - offsetX) / (CELL_SIZE * scale));
    const gy = Math.floor((y - offsetY) / (CELL_SIZE * scale));
    return {x: gx, y: gy};
  }

  // Update visible cells positions and colors based on current offset and scale
  function updateVisibleCells() {
    const startX = Math.floor(-offsetX / (CELL_SIZE * scale));
    const startY = Math.floor(-offsetY / (CELL_SIZE * scale));
    for(let i=0; i<VISIBLE_CELLS; i++) {
      for(let j=0; j<VISIBLE_CELLS; j++) {
        const index = i * VISIBLE_CELLS + j;
        const cell = visibleCells[index];
        const gridX = startX + j;
        const gridY = startY + i;
        if(gridX < 0 || gridY < 0 || gridX >= GRID_SIZE || gridY >= GRID_SIZE){
          cell.style.display = 'none';
          continue;
        }
        cell.style.display = 'block';
        cell.style.width = (CELL_SIZE * scale) + 'px';
        cell.style.height = (CELL_SIZE * scale) + 'px';
        cell.style.position = 'absolute';
        cell.style.left = (offsetX + gridX * CELL_SIZE * scale) + 'px';
        cell.style.top = (offsetY + gridY * CELL_SIZE * scale) + 'px';

        // Set color if any
        const key = gridX + '_' + gridY;
        if(coloredSquares[key]){
          cell.style.backgroundColor = coloredSquares[key];
          cell.style.borderColor = 'black';
        } else {
          cell.style.backgroundColor = 'white';
          cell.style.borderColor = '#ccc';
        }
        cell.dataset.gridX = gridX;
        cell.dataset.gridY = gridY;
      }
    }
  }

  // Initial render
  updateVisibleCells();

  // Handle pan with mouse drag
  let isPanning = false;
  let panStart = {x:0,y:0};
  frame.addEventListener('mousedown', e => {
    isPanning = true;
    panStart = {x: e.clientX - offsetX, y: e.clientY - offsetY};
  });
  window.addEventListener('mouseup', e => {
    isPanning = false;
  });
  window.addEventListener('mousemove', e => {
    if(isPanning){
      offsetX = e.clientX - panStart.x;
      offsetY = e.clientY - panStart.y;
      updateVisibleCells();
      drawMinimap();
    }
  });

  // Handle zoom with wheel
  frame.addEventListener('wheel', e => {
    e.preventDefault();
    let oldScale = scale;
    if(e.deltaY < 0) scale *= 1.1;
    else scale /= 1.1;
    scale = Math.min(Math.max(0.1, scale), 5);

    // Zoom around cursor
    const rect = frame.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;

    offsetX = cx - ((cx - offsetX) / oldScale) * scale;
    offsetY = cy - ((cy - offsetY) / oldScale) * scale;

    updateVisibleCells();
    drawMinimap();
  }, {passive:false});

  // Color picker popup logic
  grid.addEventListener('click', e => {
    // Ignore if clicking on color picker popup
    if(e.target === colorPicker || e.target === colorConfirmBtn || e.target === colorCancelBtn) return;

    const cellEl = e.target.closest('.cell');
    if(!cellEl) return;

    const x = parseInt(cellEl.dataset.gridX);
    const y = parseInt(cellEl.dataset.gridY);
    if(!x && x !== 0) return;
    if(!y && y !== 0) return;

    const key = x + '_' + y;
    if(coloredSquares[key]){
      alert("This square is already colored and cannot be changed.");
      return;
    }

    selectedCell = {x,y};

    // Show popup
    colorPicker.value = "#ff0000";
    colorPopup.style.display = 'block';
  });

  colorConfirmBtn.addEventListener('click', () => {
    if(!selectedCell) return;
    const key = selectedCell.x + '_' + selectedCell.y;
    const color = colorPicker.value;
    coloredSquares[key] = color;
    updateVisibleCells();
    drawMinimap();
    sendColorUpdate(selectedCell.x, selectedCell.y, color);
    selectedCell = null;
    colorPopup.style.display = 'none';
  });
  colorCancelBtn.addEventListener('click', () => {
    selectedCell = null;
    colorPopup.style.display = 'none';
  });

  // Minimap drawing
  function drawMinimap() {
    minimap.width = minimap.clientWidth;
    minimap.height = minimap.clientHeight;
    const ctx = minimapCtx;
    ctx.clearRect(0, 0, minimap.width, minimap.height);

    // Draw colored pixels
    const scaleX = minimap.width / GRID_SIZE;
    const scaleY = minimap.height / GRID_SIZE;
    ctx.fillStyle = 'gray';
    for(const key in coloredSquares){
      const [x, y] = key.split('_').map(Number);
      ctx.fillStyle = coloredSquares[key];
      ctx.fillRect(x * scaleX, y * scaleY, scaleX, scaleY);
    }

    // Draw viewport rectangle
    const viewX = -offsetX / (CELL_SIZE * scale) * scaleX;
    const viewY = -offsetY / (CELL_SIZE * scale) * scaleY;
    const viewW = VISIBLE_CELLS / GRID_SIZE * minimap.width;
    const viewH = VISIBLE_CELLS / GRID_SIZE * minimap.height;

    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.strokeRect(viewX, viewY, viewW, viewH);
  }

  drawMinimap();

  // --- WebSocket for real-time updates ---

  // Replace this URL with your backend WS URL (Replit or your server)
  const WS_URL = 'ws://localhost:8765';

  let ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    console.log('Connected to server');
    // Request current colored squares state
    ws.send(JSON.stringify({type: 'request_state'}));
  };
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if(data.type === 'state'){
      // Full state update
      Object.assign(coloredSquares, data.coloredSquares);
      updateVisibleCells();
      drawMinimap();
    } else if(data.type === 'color_update'){
      // New colored square from other user
      const key = data.x + '_' + data.y;
      coloredSquares[key] = data.color;
      updateVisibleCells();
      drawMinimap();
    }
  };
  ws.onclose = () => {
    console.log('Disconnected from server');
  };
  ws.onerror = (err) => {
    console.error('WebSocket error', err);
  };

  function sendColorUpdate(x, y, color) {
    if(ws.readyState === WebSocket.OPEN){
      ws.send(JSON.stringify({type:'color_update', x, y, color}));
    }
  }

</script>
</body>
</html>
