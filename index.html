<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Invisible Million</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
    }

    #top {
      padding: 20px;
      background: #f5f5f5;
    }

    #top p {
      margin: 0 0 10px;
    }

    #donateBtn {
      padding: 10px 20px;
      background-color: #0070ba;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
    }

    #minimap {
      margin: 20px auto;
      display: block;
      border: 2px solid black;
      background: white;
    }

    #frame {
      position: relative;
      width: 90vw;
      max-width: 600px;
      height: 90vw;
      max-height: 600px;
      border: 5px solid black;
      margin: 0 auto;
      overflow: hidden;
    }

    #gridCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    #colorPicker {
      position: fixed;
      left: -9999px;
    }
  </style>
</head>
<body>
  <div id="top">
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
    <p>Vestibulum imperdiet, risus nec fermentum ultricies, nulla leo bibendum sem.</p>
    <p>Fusce at sapien eget justo laoreet cursus.</p>
    <p>Aliquam erat volutpat. Integer in cursus augue.</p>
    <p>Morbi dignissim ligula id purus sagittis, nec tincidunt erat iaculis.</p>
    <p>Sed vulputate augue vel turpis suscipit tempor.</p>
    <p>Ut efficitur metus at nunc feugiat dignissim.</p>
    <p>Nam at diam a justo viverra elementum at ut nibh.</p>
    <p>Praesent eget metus in turpis commodo ultrices.</p>
    <p>Donec nec urna nec nunc volutpat fringilla.</p>
    <button id="donateBtn">Donate (Mock)</button>
  </div>

  <canvas id="minimap" width="150" height="150"></canvas>

  <div id="frame">
    <canvas id="gridCanvas" width="2000" height="2000"></canvas>
  </div>

  <input type="color" id="colorPicker" />

  <script>
    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");
    const minimap = document.getElementById("minimap");
    const mctx = minimap.getContext("2d");
    const frame = document.getElementById("frame");
    const colorPicker = document.getElementById("colorPicker");

    const gridSize = 1000;
    const cellSize = 10;

    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let paintedSquares = {};

    const backendUrl = "https://your-replit-backend-url.repl.co";

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          const key = `${x},${y}`;
          const color = paintedSquares[key]?.color || "#e0e0e0";

          const px = x * cellSize * scale + offsetX;
          const py = y * cellSize * scale + offsetY;
          const size = cellSize * scale;

          if (
            px + size < 0 || px > frame.clientWidth ||
            py + size < 0 || py > frame.clientHeight
          ) continue;

          ctx.fillStyle = color;
          ctx.fillRect(px, py, size, size);
          ctx.strokeStyle = "#ccc";
          ctx.strokeRect(px, py, size, size);
        }
      }
      drawMinimap();
    }

    function drawMinimap() {
      const mw = minimap.width;
      const mh = minimap.height;

      mctx.clearRect(0, 0, mw, mh);
      mctx.fillStyle = "#e0e0e0";
      mctx.fillRect(0, 0, mw, mh);

      for (const key in paintedSquares) {
        const [x, y] = key.split(",").map(Number);
        const miniX = (x / gridSize) * mw;
        const miniY = (y / gridSize) * mh;
        mctx.fillStyle = paintedSquares[key].color;
        mctx.fillRect(miniX, miniY, 1, 1);
      }
    }

    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
    });

    canvas.addEventListener("mouseup", () => isDragging = false);
    canvas.addEventListener("mouseleave", () => isDragging = false);
    canvas.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      offsetX += e.clientX - dragStart.x;
      offsetY += e.clientY - dragStart.y;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      drawGrid();
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoom = e.deltaY < 0 ? 1.1 : 0.9;
      const mx = e.clientX - frame.getBoundingClientRect().left;
      const my = e.clientY - frame.getBoundingClientRect().top;

      const wx = (mx - offsetX) / scale;
      const wy = (my - offsetY) / scale;

      scale *= zoom;
      offsetX = mx - wx * scale;
      offsetY = my - wy * scale;
      drawGrid();
    });

    canvas.addEventListener("click", async (e) => {
      const rect = frame.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const gridX = Math.floor((mouseX - offsetX) / (cellSize * scale));
      const gridY = Math.floor((mouseY - offsetY) / (cellSize * scale));
      const key = `${gridX},${gridY}`;

      if (paintedSquares[key]) {
        alert("This square is already painted.");
        return;
      }

      colorPicker.oninput = async () => {
        const color = colorPicker.value;

        const res = await fetch(`${backendUrl}/paint`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ x: gridX, y: gridY, color, tx: "mock" })
        });

        if (res.ok) {
          paintedSquares[key] = { color };
          drawGrid();
        } else {
          alert("Error painting square");
        }
      };
      colorPicker.click();
    });

    async function fetchPaintedSquares() {
      try {
        const res = await fetch(`${backendUrl}/painted`);
        paintedSquares = await res.json();
        drawGrid();
      } catch (err) {
        console.error("Failed to fetch squares", err);
      }
    }

    fetchPaintedSquares();
  </script>
</body>
</html>
