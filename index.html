<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Invisible Million</title>
<style>
  body {
    margin: 0; padding: 0;
    font-family: Arial, sans-serif;
    background-color: #111;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  header {
    max-width: 600px;
    padding: 1.5rem;
    text-align: center;
  }
  #container {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
  }
  #minimap-container, #mainframe {
    position: relative;
    width: 400px;
    height: 400px;
    border: 3px solid white;
    background-color: #ddd;
  }
  canvas {
    position: absolute;
    top: 0; left: 0;
    cursor: grab;
    image-rendering: pixelated;
    background-color: #ddd;
  }
  #viewport-box {
    position: absolute;
    border: 2px solid red;
    pointer-events: none;
    background: rgba(255, 0, 0, 0.15);
  }
  #colorModal {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: #222;
    padding: 20px 25px;
    border-radius: 8px;
    box-shadow: 0 0 15px #ff4444cc;
    color: #fff;
    user-select: none;
    text-align: center;
    min-width: 250px;
  }
  #colorModal h2 {
    margin: 0 0 10px;
    font-weight: normal;
  }
  #colorPicker {
    width: 100%;
    height: 40px;
    border: none;
    cursor: pointer;
    background-color: transparent;
    margin-bottom: 15px;
  }
  #colorModal button {
    background-color: #ff4444;
    border: none;
    padding: 8px 20px;
    color: white;
    font-weight: bold;
    border-radius: 5px;
    cursor: pointer;
    margin: 0 10px;
    transition: background-color 0.2s ease;
  }
  #colorModal button:hover {
    background-color: #cc0000;
  }
  #counter {
    font-size: 1.2rem;
    margin-top: 10px;
  }
</style>
</head>
<body>
<header>
  <h1>The Invisible Million</h1>
  <p>Zoom, esplora e colora un quadrato sulla griglia invisibile da un milione di celle!</p>
  <div id="counter">Loading painted squares...</div>
</header>

<div id="container">
  <div id="minimap-container">
    <canvas id="minimap" width="400" height="400"></canvas>
    <div id="viewport-box"></div>
  </div>
  <div id="mainframe">
    <canvas id="mainCanvas" width="400" height="400"></canvas>
  </div>
</div>

<div id="colorModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <h2 id="modalTitle">Scegli un colore</h2>
  <input type="color" id="colorPicker" value="#ff0000" />
  <div>
    <button id="cancelBtn">Annulla</button>
    <button id="okBtn">OK</button>
  </div>
</div>

<script>
const GRID_SIZE = 1000;
const CANVAS_SIZE = 400;  // dimensione canvas px
const MINIMAP_SIZE = 400; // stessa dimensione minimap
const SCALE_FACTOR = GRID_SIZE / MINIMAP_SIZE; // 2.5

let zoom = parseFloat(localStorage.getItem("zoom")) || 5;
let offsetX = parseFloat(localStorage.getItem("offsetX")) || 0;
let offsetY = parseFloat(localStorage.getItem("offsetY")) || 0;

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const minimap = document.getElementById('minimap');
const miniCtx = minimap.getContext('2d');
miniCtx.imageSmoothingEnabled = false;

const viewportBox = document.getElementById('viewport-box');
const counter = document.getElementById('counter');

let gridData = {};
let selectedSquare = null;

function clampOffsets() {
  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  offsetX = Math.min(Math.max(offsetX, 0), GRID_SIZE - visibleSquares);
  offsetY = Math.min(Math.max(offsetY, 0), GRID_SIZE - visibleSquares);
}

function drawGrid() {
  ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
  const pixelSize = zoom;
  const visibleSquares = Math.floor(CANVAS_SIZE / pixelSize);

  clampOffsets();

  // sfondo griglia
  ctx.fillStyle = '#ddd';
  ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

  // linee griglia
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = 0; x <= visibleSquares; x++) {
    const px = x * pixelSize;
    ctx.moveTo(px, 0);
    ctx.lineTo(px, visibleSquares * pixelSize);
  }
  for (let y = 0; y <= visibleSquares; y++) {
    const py = y * pixelSize;
    ctx.moveTo(0, py);
    ctx.lineTo(visibleSquares * pixelSize, py);
  }
  ctx.stroke();

  // dipingi quadrati
  for (let x = 0; x < visibleSquares; x++) {
    for (let y = 0; y < visibleSquares; y++) {
      const gridX = Math.floor(offsetX) + x;
      const gridY = Math.floor(offsetY) + y;
      const key = `${gridX},${gridY}`;
      if (gridData[key]) {
        ctx.fillStyle = gridData[key].color;
        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
      }
    }
  }

  // evidenzia quadrato selezionato
  if (selectedSquare) {
    const selX = selectedSquare.x - Math.floor(offsetX);
    const selY = selectedSquare.y - Math.floor(offsetY);
    if (selX >= 0 && selX < visibleSquares && selY >= 0 && selY < visibleSquares) {
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 3;
      ctx.strokeRect(selX * pixelSize, selY * pixelSize, pixelSize, pixelSize);
    }
  }
}

function drawMinimap() {
  miniCtx.clearRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
  miniCtx.fillStyle = '#ddd';
  miniCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

  // dipingi quadrati sulla minimap
  for (const key in gridData) {
    const [x, y] = key.split(',').map(Number);
    miniCtx.fillStyle = gridData[key].color;
    miniCtx.fillRect(x / SCALE_FACTOR, y / SCALE_FACTOR, 1 / SCALE_FACTOR, 1 / SCALE_FACTOR);
  }

  // disegna viewport sulla minimap
  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  const scale = MINIMAP_SIZE / GRID_SIZE;
  const boxWidth = visibleSquares * scale;
  const boxHeight = visibleSquares * scale;
  const boxLeft = offsetX * scale;
  const boxTop = offsetY * scale;

  viewportBox.style.width = `${boxWidth}px`;
  viewportBox.style.height = `${boxHeight}px`;
  viewportBox.style.left = `${boxLeft}px`;
  viewportBox.style.top = `${boxTop}px`;
}

function render() {
  drawGrid();
  drawMinimap();
  localStorage.setItem("zoom", zoom);
  localStorage.setItem("offsetX", offsetX);
  localStorage.setItem("offsetY", offsetY);
}

function openColorModal(x, y) {
  selectedSquare = { x, y };
  colorPicker.value = gridData[`${x},${y}`]?.color || '#ff0000';
  colorModal.style.display = 'block';
  colorPicker.focus();
}

function closeColorModal() {
  colorModal.style.display = 'none';
  selectedSquare = null;
}

function paintSquare(x, y, color) {
  // POST al backend senza tx
  fetch('/paint', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ x, y, color })
  })
  .then(res => res.json())
  .then(data => {
    if(data.success) {
      gridData[`${x},${y}`] = { color };
      counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
      render();
      closeColorModal();
    } else {
      alert(data.error || 'Errore nella pittura');
      closeColorModal();
    }
  })
  .catch(() => {
    alert('Errore di rete');
    closeColorModal();
  });
}

fetch("/painted")
  .then(res => res.json())
  .then(data => {
    gridData = data;
    counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
    render();
  })
  .catch(() => {
    counter.textContent = "Errore nel caricamento dei dati.";
  });

// Zoom con rotella
document.getElementById('mainframe').addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const oldZoom = zoom;
  const delta = e.deltaY > 0 ? -0.5 : 0.5;
  zoom = Math.min(20, Math.max(1, zoom + delta));
  offsetX += mx / oldZoom - mx / zoom;
  offsetY += my / oldZoom - my / zoom;
  render();
}, { passive: false });

// Drag per muovere la vista
let isDragging = false;
let dragStart = { x: 0, y: 0 };
canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
  canvas.style.cursor = 'grabbing';
});
window.addEventListener('mouseup', () => {
  isDragging = false;
  canvas.style.cursor = 'grab';
});
window.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const dx = e.clientX - dragStart.x;
  const dy = e.clientY - dragStart.y;
  dragStart = { x: e.clientX, y: e.clientY };
  offsetX -= dx / zoom;
  offsetY -= dy / zoom;
  render();
});

// Click sulla minimap per spostare la vista
minimap.addEventListener('click', (e) => {
  const rect = minimap.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  offsetX = mx * SCALE_FACTOR - (CANVAS_SIZE / (2 * zoom));
  offsetY = my * SCALE_FACTOR - (CANVAS_SIZE / (2 * zoom));
  render();
});

// Click sulla griglia per selezionare quadrato e aprire modal
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  const gridX = Math.floor(offsetX + cx / zoom);
  const gridY = Math.floor(offsetY + cy / zoom);
  if(gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
    // controlla se quadrato già dipinto
    if(gridData[`${gridX},${gridY}`]) {
      alert("Quadrato già dipinto, scegli un altro.");
      return;
    }
    openColorModal(gridX, gridY);
  }
});

// Modal gestione
const colorModal = document.getElementById('colorModal');
const colorPicker = document.getElementById('colorPicker');
const cancelBtn = document.getElementById('cancelBtn');
const okBtn = document.getElementById('okBtn');

cancelBtn.addEventListener('click', () => {
  closeColorModal();
});

okBtn.addEventListener('click', () => {
  if (!selectedSquare) return;
  paintSquare(selectedSquare.x, selectedSquare.y, colorPicker.value);
});

window.addEventListener('keydown', e => {
  if (e.key === 'Escape' && colorModal.style.display === 'block') {
    closeColorModal();
  }
});
</script>
</body>
</html>
