<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Invisible Million</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
    }
    header {
      position: sticky;
      top: 0;
      background: white;
      padding: 10px;
      border-bottom: 2px solid #000;
      z-index: 1000;
    }
    header a {
      margin-right: 20px;
      text-decoration: none;
      color: black;
      font-weight: bold;
    }
    #frame {
      position: relative;
      border: 4px solid black;
      width: 100vw;
      height: calc(100vh - 60px);
      box-sizing: border-box;
      overflow: hidden;
    }
    #mainCanvas {
      display: block;
    }
    #minimap {
      position: absolute;
      width: 150px;
      height: 150px;
      bottom: 10px;
      right: 10px;
      border: 2px solid red;
      background: white;
      z-index: 10;
      cursor: pointer;
    }
    #paypal-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: gold;
      border: none;
      padding: 10px 15px;
      font-weight: bold;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <header>
    <a href="about.html">About</a>
    <a href="faq.html">FAQ</a>
  </header>
  <div id="frame">
    <canvas id="mainCanvas"></canvas>
    <canvas id="minimap"></canvas>
    <button id="paypal-btn">Donate (Dummy)</button>
  </div>

  <script>
    const canvas = document.getElementById('mainCanvas');
    const minimap = document.getElementById('minimap');
    const ctx = canvas.getContext('2d');
    const miniCtx = minimap.getContext('2d');

    const GRID_SIZE = 1000;
    const CELL_SIZE = 10;
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let dragStart = {};

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 60;

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const visibleCols = Math.ceil(canvas.width / (CELL_SIZE * scale));
      const visibleRows = Math.ceil(canvas.height / (CELL_SIZE * scale));
      const startCol = Math.floor(offsetX / CELL_SIZE);
      const startRow = Math.floor(offsetY / CELL_SIZE);

      for (let y = startRow; y < startRow + visibleRows; y++) {
        for (let x = startCol; x < startCol + visibleCols; x++) {
          if (x >= 0 && y >= 0 && x < GRID_SIZE && y < GRID_SIZE) {
            ctx.fillStyle = '#ccc';
            ctx.fillRect(
              (x * CELL_SIZE - offsetX) * scale,
              (y * CELL_SIZE - offsetY) * scale,
              CELL_SIZE * scale,
              CELL_SIZE * scale
            );
          }
        }
      }
    }

    function drawMinimap() {
      miniCtx.clearRect(0, 0, minimap.width, minimap.height);
      miniCtx.fillStyle = '#eee';
      miniCtx.fillRect(0, 0, minimap.width, minimap.height);
      miniCtx.fillStyle = '#888';
      miniCtx.fillRect(0, 0, minimap.width, minimap.height);

      const viewW = canvas.width / (GRID_SIZE * CELL_SIZE * scale);
      const viewH = canvas.height / (GRID_SIZE * CELL_SIZE * scale);
      const viewX = offsetX / (GRID_SIZE * CELL_SIZE);
      const viewY = offsetY / (GRID_SIZE * CELL_SIZE);

      miniCtx.strokeStyle = 'red';
      miniCtx.lineWidth = 2;
      miniCtx.strokeRect(
        viewX * minimap.width,
        viewY * minimap.height,
        viewW * minimap.width,
        viewH * minimap.height
      );
    }

    function render() {
      drawGrid();
      drawMinimap();
    }

    canvas.addEventListener('mousedown', e => {
      isDragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
    });

    canvas.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = (e.clientX - dragStart.x) / scale;
      const dy = (e.clientY - dragStart.y) / scale;
      offsetX -= dx;
      offsetY -= dy;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      render();
    });

    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);

    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomFactor = 1.1;
      const mouseX = e.offsetX / scale + offsetX;
      const mouseY = e.offsetY / scale + offsetY;
      if (e.deltaY < 0) {
        scale *= zoomFactor;
      } else {
        scale /= zoomFactor;
      }
      offsetX = mouseX - (e.offsetX / scale);
      offsetY = mouseY - (e.offsetY / scale);
      render();
    });

    minimap.addEventListener('click', e => {
      const rect = minimap.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      offsetX = (x / minimap.width) * (GRID_SIZE * CELL_SIZE) - canvas.width / (2 * scale);
      offsetY = (y / minimap.height) * (GRID_SIZE * CELL_SIZE) - canvas.height / (2 * scale);
      render();
    });

    canvas.addEventListener('dblclick', () => {
      if (!document.fullscreenElement) {
        canvas.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });

    render();
  </script>
</body>
</html>
