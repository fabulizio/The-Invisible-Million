<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Griglia Interattiva Virtualizzata</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: white;
      font-family: sans-serif;
      overflow: hidden;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 10;
    }
    canvas {
      display: block;
      background: #222;
    }
  </style>
</head>
<body>
  <div id="info">Celle colorate: <span id="counter">0</span></div>
  <canvas id="gridCanvas" width="800" height="800"></canvas>

  <script>
    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");
    const canvasSize = canvas.width;
    const gridSize = 1000;

    let zoom = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let hoverX = -1, hoverY = -1;

    const coloredCells = new Map();
    const counter = document.getElementById("counter");

    function getCellId(x, y) {
      return y * gridSize + x;
    }

    function updateCounter() {
      counter.textContent = coloredCells.size;
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvasSize, canvasSize);
      const cellSize = (canvasSize / gridSize) * zoom;
      const buffer = 2;

      const startX = Math.max(0, Math.floor(offsetX / cellSize) - buffer);
      const startY = Math.max(0, Math.floor(offsetY / cellSize) - buffer);
      const endX = Math.min(gridSize, Math.ceil((offsetX + canvasSize) / cellSize) + buffer);
      const endY = Math.min(gridSize, Math.ceil((offsetY + canvasSize) / cellSize) + buffer);

      for (let x = startX; x < endX; x++) {
        for (let y = startY; y < endY; y++) {
          const screenX = x * cellSize - offsetX;
          const screenY = y * cellSize - offsetY;
          const cellId = getCellId(x, y);

          const color = coloredCells.get(cellId);
          if (color) {
            ctx.fillStyle = color;
            ctx.fillRect(screenX, screenY, cellSize, cellSize);
          }

          ctx.strokeStyle = "#333";
          ctx.strokeRect(screenX, screenY, cellSize, cellSize);

          // Hover effect
          if (x === hoverX && y === hoverY) {
            ctx.strokeStyle = "cyan";
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX, screenY, cellSize, cellSize);
            ctx.lineWidth = 1;
          }
        }
      }
    }

    let redrawPending = false;
    function requestRedraw() {
      if (!redrawPending) {
        redrawPending = true;
        requestAnimationFrame(() => {
          drawGrid();
          redrawPending = false;
        });
      }
    }

    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStartX = e.clientX + offsetX;
      dragStartY = e.clientY + offsetY;
    });

    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        offsetX = dragStartX - e.clientX;
        offsetY = dragStartY - e.clientY;
        requestRedraw();
      } else {
        const cellSize = (canvasSize / gridSize) * zoom;
        const x = Math.floor((e.offsetX + offsetX) / cellSize);
        const y = Math.floor((e.offsetY + offsetY) / cellSize);
        if (x !== hoverX || y !== hoverY) {
          hoverX = x;
          hoverY = y;
          requestRedraw();
        }
      }
    });

    canvas.addEventListener("mouseup", () => {
      isDragging = false;
    });

    canvas.addEventListener("mouseleave", () => {
      isDragging = false;
      hoverX = -1;
      hoverY = -1;
      requestRedraw();
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = 1.1;
      const mouseX = e.offsetX;
      const mouseY = e.offsetY;

      const worldX = (mouseX + offsetX) / zoom;
      const worldY = (mouseY + offsetY) / zoom;

      if (e.deltaY < 0) {
        zoom *= zoomFactor;
      } else {
        zoom /= zoomFactor;
      }

      offsetX = worldX * zoom - mouseX;
      offsetY = worldY * zoom - mouseY;
      requestRedraw();
    });

    canvas.addEventListener("click", (e) => {
      const cellSize = (canvasSize / gridSize) * zoom;
      const x = Math.floor((e.offsetX + offsetX) / cellSize);
      const y = Math.floor((e.offsetY + offsetY) / cellSize);
      const cellId = getCellId(x, y);

      if (coloredCells.has(cellId)) {
        coloredCells.delete(cellId);
      } else {
        coloredCells.set(cellId, "magenta");
      }
      updateCounter();
      requestRedraw();
    });

    updateCounter();
    requestRedraw();
  </script>
</body>
</html>
