<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Invisible Million</title>
<style>
  body {
    margin: 0; padding: 0;
    font-family: Arial, sans-serif;
    background-color: #111;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  header {
    max-width: 600px;
    padding: 1.5rem;
    text-align: center;
  }
  #container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-bottom: 30px;
    width: 420px; /* sufficiente per canvas */
  }
  #minimap-container, #mainframe {
    position: relative;
    width: 400px;
    height: 400px;
    border: 3px solid white;
    background-color: #ddd;
  }
  #mainCanvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    cursor: default;
    image-rendering: pixelated;
  }
  #minimap {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    cursor: grab;
    image-rendering: pixelated;
  }
  #viewport-box {
    position: absolute;
    border: 2px solid red;
    pointer-events: none;
    background: rgba(255, 0, 0, 0.15);
  }
  #colorModal {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: #222;
    padding: 20px 25px;
    border-radius: 8px;
    box-shadow: 0 0 15px #ff4444cc;
    color: #fff;
    user-select: none;
    text-align: center;
    min-width: 250px;
  }
  #colorModal h2 {
    margin: 0 0 10px;
    font-weight: normal;
  }
  #colorPicker {
    width: 100%;
    height: 40px;
    border: none;
    background-color: transparent;
    margin-bottom: 15px;
  }
  #colorModal button {
    background-color: #ff4444;
    border: none;
    padding: 8px 20px;
    color: white;
    font-weight: bold;
    border-radius: 5px;
    margin: 0 10px;
    transition: background-color 0.2s ease;
    cursor: pointer;
  }
  #colorModal button:hover {
    background-color: #cc0000;
  }
  #counter {
    font-size: 1.2rem;
    margin-top: 10px;
  }
</style>
</head>
<body>
<header>
  <h1>The Invisible Million</h1>
  <p>Zoom, esplora e colora un quadrato sulla griglia invisibile da un milione di celle!</p>
  <div id="counter">Loading painted squares...</div>
</header>

<div id="container">
  <div id="minimap-container">
    <canvas id="minimap" width="400" height="400"></canvas>
    <div id="viewport-box"></div>
  </div>
  <div id="mainframe">
    <canvas id="mainCanvas" width="400" height="400"></canvas>
  </div>
</div>

<div id="colorModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <h2 id="modalTitle">Scegli un colore</h2>
  <input type="color" id="colorPicker" value="#ff0000" />
  <div>
    <button id="cancelBtn">Annulla</button>
    <button id="okBtn">OK</button>
  </div>
</div>

<script>
const BACKEND_URL = "https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev";

const GRID_SIZE = 1000;
const CANVAS_SIZE = 400;
const MINIMAP_SIZE = 400;
const SCALE_FACTOR = GRID_SIZE / MINIMAP_SIZE;

let zoom = parseFloat(localStorage.getItem("zoom")) || 5;
let offsetX = parseFloat(localStorage.getItem("offsetX")) || 0;
let offsetY = parseFloat(localStorage.getItem("offsetY")) || 0;

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const minimap = document.getElementById('minimap');
const miniCtx = minimap.getContext('2d');
miniCtx.imageSmoothingEnabled = false;

const viewportBox = document.getElementById('viewport-box');
const counter = document.getElementById('counter');

let gridData = {};
let selectedSquare = null;

function clampOffsets() {
  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  offsetX = Math.min(Math.max(offsetX, 0), GRID_SIZE - visibleSquares);
  offsetY = Math.min(Math.max(offsetY, 0), GRID_SIZE - visibleSquares);
}

function drawGrid() {
  ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
  const pixelSize = zoom;
  const visibleSquares = Math.floor(CANVAS_SIZE / pixelSize);

  clampOffsets();

  ctx.fillStyle = '#ddd';
  ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = 0; x <= visibleSquares; x++) {
    const px = x * pixelSize;
    ctx.moveTo(px, 0);
    ctx.lineTo(px, visibleSquares * pixelSize);
  }
  for (let y = 0; y <= visibleSquares; y++) {
    const py = y * pixelSize;
    ctx.moveTo(0, py);
    ctx.lineTo(visibleSquares * pixelSize, py);
  }
  ctx.stroke();

  for (let x = 0; x < visibleSquares; x++) {
    for (let y = 0; y < visibleSquares; y++) {
      const gridX = Math.floor(offsetX) + x;
      const gridY = Math.floor(offsetY) + y;
      const key = `${gridX},${gridY}`;
      if (gridData[key]) {
        ctx.fillStyle = gridData[key].color;
        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
      }
    }
  }

  if (selectedSquare) {
    const selX = selectedSquare.x - Math.floor(offsetX);
    const selY = selectedSquare.y - Math.floor(offsetY);
    if (selX >= 0 && selX < visibleSquares && selY >= 0 && selY < visibleSquares) {
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 3;
      ctx.strokeRect(selX * pixelSize, selY * pixelSize, pixelSize, pixelSize);
    }
  }
}

function drawMinimap() {
  miniCtx.clearRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
  miniCtx.fillStyle = '#ddd';
  miniCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

  for (const key in gridData) {
    const [x, y] = key.split(',').map(Number);
    miniCtx.fillStyle = gridData[key].color;
    miniCtx.fillRect(x / SCALE_FACTOR, y / SCALE_FACTOR, 1 / SCALE_FACTOR, 1 / SCALE_FACTOR);
  }

  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  const scale = MINIMAP_SIZE / GRID_SIZE;
  const boxWidth = visibleSquares * scale;
  const boxHeight = visibleSquares * scale;
  const boxLeft = offsetX * scale;
  const boxTop = offsetY * scale;

  viewportBox.style.width = `${boxWidth}px`;
  viewportBox.style.height = `${boxHeight}px`;
  viewportBox.style.left = `${boxLeft}px`;
  viewportBox.style.top = `${boxTop}px`;
}

function render() {
  drawGrid();
  drawMinimap();
  localStorage.setItem("zoom", zoom);
  localStorage.setItem("offsetX", offsetX);
  localStorage.setItem("offsetY", offsetY);
}

function openColorModal(x, y) {
  selectedSquare = { x, y };
  colorPicker.value = gridData[`${x},${y}`]?.color || '#ff0000';
  colorModal.style.display = 'block';
  colorPicker.focus();
}

function closeColorModal() {
  colorModal.style.display = 'none';
  selectedSquare = null;
}

function paintSquare(x, y, color) {
  fetch(`${BACKEND_URL}/paint`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ x, y, color })
  })
  .then(res => res.json())
  .then(data => {
    if(data.success) {
      gridData[`${x},${y}`] = { color };
      counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
      render();
      closeColorModal();
    } else {
      alert(data.error || 'Errore nella pittura');
      closeColorModal();
    }
  })
  .catch(() => {
    alert('Errore di rete');
    closeColorModal();
  });
}

fetch(`${BACKEND_URL}/painted`)
  .then(res => res.json())
  .then(data => {
    gridData = data;
    counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
    render();
  })
  .catch(() => {
    counter.textContent = "Errore nel caricamento dei dati.";
  });

// Zoom con rotella sulla griglia
document.getElementById('mainframe').addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const oldZoom = zoom;
  const delta = e.deltaY > 0 ? -0.5 : 0.5;
  zoom = Math.min(20, Math.max(1, zoom + delta));
  offsetX += mx / oldZoom - mx / zoom;
  offsetY += my / oldZoom - my / zoom;
  render();
}, { passive: false });

// Drag per spostare la griglia (canvas)
let isDragging = false;
let dragStart = { x: 0, y: 0 };
canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
  canvas.style.cursor = 'default';
});
window.addEventListener('mouseup', () => {
  isDragging = false;
  canvas.style.cursor = 'default';
});
window.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const dx = (dragStart.x - e.clientX) / zoom;
  const dy = (dragStart.y - e.clientY) / zoom;
  offsetX = Math.min(Math.max(offsetX + dx, 0), GRID_SIZE - CANVAS_SIZE / zoom);
  offsetY = Math.min(Math.max(offsetY + dy, 0), GRID_SIZE - CANVAS_SIZE / zoom);
  dragStart = { x: e.clientX, y: e.clientY };
  render();
});

// Click su canvas per aprire il color modal
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor(offsetX + (e.clientX - rect.left) / zoom);
  const y = Math.floor(offsetY + (e.clientY - rect.top) / zoom);
  openColorModal(x, y);
});

// Modal gestione
const colorModal = document.getElementById('colorModal');
const colorPicker = document.getElementById('colorPicker');
const cancelBtn = document.getElementById('cancelBtn');
const okBtn = document.getElementById('okBtn');

cancelBtn.addEventListener('click', closeColorModal);
colorModal.addEventListener('click', (e) => {
  if (e.target === colorModal) closeColorModal();
});
okBtn.addEventListener('click', () => {
  if (selectedSquare) {
    paintSquare(selectedSquare.x, selectedSquare.y, colorPicker.value);
  }
});

// Drag sulla minimap per spostare viewport box
let minimapDragging = false;

minimap.addEventListener('mousedown', (e) => {
  minimapDragging = true;
  minimap.style.cursor = 'grabbing';
});

window.addEventListener('mouseup', () => {
  if (minimapDragging) {
    minimapDragging = false;
    minimap.style.cursor = 'grab';
  }
});

window.addEventListener('mousemove', (e) => {
  if (!minimapDragging) return;

  const rect = minimap.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Limita all'area della minimap (tenendo conto dimensione viewport)
  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  const scale = MINIMAP_SIZE / GRID_SIZE;
  const boxWidth = visibleSquares * scale;
  const boxHeight = visibleSquares * scale;

  x = Math.min(Math.max(x, 0), MINIMAP_SIZE - boxWidth);
  y = Math.min(Math.max(y, 0), MINIMAP_SIZE - boxHeight);

  offsetX = x / scale;
  offsetY = y / scale;

  render();
});

// Clic sulla minimap per spostare viewport
minimap.addEventListener('click', (e) => {
  if (minimapDragging) return; // evita conflitti con drag
  const rect = minimap.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  const scale = MINIMAP_SIZE / GRID_SIZE;
  const boxWidth = visibleSquares * scale;
  const boxHeight = visibleSquares * scale;

  // Centra viewport attorno al click (tenendo conto dimensione viewport)
  let newX = x - boxWidth / 2;
  let newY = y - boxHeight / 2;

  newX = Math.min(Math.max(newX, 0), MINIMAP_SIZE - boxWidth);
  newY = Math.min(Math.max(newY, 0), MINIMAP_SIZE - boxHeight);

  offsetX = newX / scale;
  offsetY = newY / scale;

  render();
});

// Disabilita pinch-to-zoom da mobile
document.addEventListener('touchstart', (e) => {
  if (e.touches.length > 1) e.preventDefault();
}, { passive: false });
document.addEventListener('touchmove', (e) => {
  if (e.touches.length > 1) e.preventDefault();
}, { passive: false });

// Zoom da tastiera (+ e -)
window.addEventListener('keydown', (e) => {
  if (e.key === '+') {
    zoom = Math.min(20, zoom + 1);
    render();
  } else if (e.key === '-') {
    zoom = Math.max(1, zoom - 1);
    render();
  }
});

render();
</script>
</body>
</html>
