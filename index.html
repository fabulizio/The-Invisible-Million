<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Invisible Million - Grid</title>
<style>
  body {
    margin: 20px;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #narrative {
    max-width: 1000px;
    margin-bottom: 15px;
  }
  #minimap-container, #mainframe {
    position: relative;
    width: 600px;
    height: 600px;
    margin-bottom: 15px;
    border: 5px solid black;
    box-sizing: border-box;
  }
  #minimap {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    background: #eee;
  }
  #mainframe {
    overflow: hidden;
  }
  #grid-canvas {
    cursor: crosshair;
    image-rendering: pixelated;
    transform-origin: top left;
  }
  #palette {
    position: fixed;
    display: none;
    background: white;
    border: 1px solid black;
    padding: 5px;
    z-index: 10;
  }
  #palette input[type=color] {
    width: 50px;
    height: 30px;
    border: none;
    padding: 0;
  }
  #palette button {
    margin-left: 5px;
  }
</style>
</head>
<body>

<div id="narrative">
  <p>
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla euismod, nisl nec vestibulum cursus, ligula odio viverra nunc, a dictum magna urna sed purus.
  </p>
  <p>
    Phasellus maximus libero at erat pulvinar, at egestas velit commodo. Vivamus dignissim mi vitae erat gravida, nec gravida metus faucibus.
  </p>
  <p>
    Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Proin imperdiet, nisl in fringilla faucibus, lorem massa porttitor dui, at condimentum sem erat at ex.
  </p>
  <!-- Add more nonsense lines as needed -->
</div>

<div id="minimap-container">
  <canvas id="minimap" width="1000" height="1000"></canvas>
</div>

<div id="mainframe">
  <canvas id="grid-canvas" width="1000" height="1000"></canvas>
</div>

<div id="palette">
  <input type="color" id="color-picker" value="#ff0000" />
  <button id="confirm-paint">Paint</button>
  <button id="cancel-paint">Cancel</button>
</div>

<script>
  const backendUrl = "https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev";

  const canvas = document.getElementById('grid-canvas');
  const ctx = canvas.getContext('2d');
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas.getContext('2d');
  const palette = document.getElementById('palette');
  const colorPicker = document.getElementById('color-picker');
  const confirmBtn = document.getElementById('confirm-paint');
  const cancelBtn = document.getElementById('cancel-paint');
  const mainframe = document.getElementById('mainframe');

  const GRID_SIZE = 1000;    // grid 1000 x 1000 squares
  const SQUARE_SIZE = 10;    // base pixel size of squares (scaled by zoom)
  let zoom = 1;

  // Zoom limits - visible squares between 50x50 and 200x200
  const MIN_VISIBLE_SQUARES = 50;
  const MAX_VISIBLE_SQUARES = 200;

  let offsetX = 0;  // for panning, not used now
  let offsetY = 0;

  let gridData = {};  // loaded from backend

  // Selected square coords for painting
  let selectedSquare = null;

  // Adjust zoom so visible squares between min and max
  function clampZoom(z) {
    const maxZoom = GRID_SIZE / MIN_VISIBLE_SQUARES;
    const minZoom = GRID_SIZE / MAX_VISIBLE_SQUARES;
    return Math.min(Math.max(z, minZoom), maxZoom);
  }

  // Load painted squares from backend
  async function loadGrid() {
    try {
      const res = await fetch(`${backendUrl}/painted`);
      if (!res.ok) throw new Error("Failed to fetch painted squares");
      gridData = await res.json();
      drawGrid();
      drawMinimap();
    } catch (e) {
      console.error(e);
    }
  }

  function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.scale(zoom, zoom);

    // Draw painted squares
    for (const key in gridData) {
      const [x, y] = key.split(',').map(Number);
      const color = gridData[key].color;
      ctx.fillStyle = color;
      ctx.fillRect(x, y, 1, 1);
    }

    // Draw grid lines if zoomed in enough
    if (zoom > 0.7) {
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 0.02;
      for(let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, GRID_SIZE);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(GRID_SIZE, i);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  function drawMinimap() {
    minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

    for (const key in gridData) {
      const [x, y] = key.split(',').map(Number);
      const color = gridData[key].color;
      minimapCtx.fillStyle = color;
      minimapCtx.fillRect(x, y, 1, 1);
    }
  }

  // Map click coords on canvas to grid coords
  function getGridCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((clientX - rect.left) / (zoom));
    const y = Math.floor((clientY - rect.top) / (zoom));
    return {x, y};
  }

  canvas.addEventListener('click', (e) => {
    const {x, y} = getGridCoords(e.clientX, e.clientY);
    const key = `${x},${y}`;
    if (gridData[key]) {
      alert("This square is already painted!");
      return;
    }
    selectedSquare = {x, y};
    showPalette(e.clientX, e.clientY);
  });

  function showPalette(pageX, pageY) {
    palette.style.left = pageX + "px";
    palette.style.top = pageY + "px";
    palette.style.display = "block";
  }

  function hidePalette() {
    palette.style.display = "none";
    selectedSquare = null;
  }

  confirmBtn.addEventListener('click', async () => {
    if (!selectedSquare) return;
    const color = colorPicker.value;
    const payload = {
      x: selectedSquare.x,
      y: selectedSquare.y,
      color,
      tx: "mock_tx_id"
    };
    try {
      const res = await fetch(`${backendUrl}/paint`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
      });
      if (res.status === 403) {
        alert("Square already painted by someone else!");
      } else if (!res.ok) {
        const err = await res.json();
        alert("Error: " + (err.error || "Unknown error"));
      } else {
        gridData[`${selectedSquare.x},${selectedSquare.y}`] = {
          color,
          timestamp: new Date().toISOString(),
          tx: "mock_tx_id"
        };
        drawGrid();
        drawMinimap();
      }
    } catch (e) {
      alert("Network error");
      console.error(e);
    }
    hidePalette();
  });

  cancelBtn.addEventListener('click', () => {
    hidePalette();
  });

  // Zoom with mouse wheel (centered)
  mainframe.addEventListener('wheel', (e) => {
    e.preventDefault();
    let newZoom = clampZoom(zoom - e.deltaY * 0.001);
    if (newZoom !== zoom) {
      zoom = newZoom;
      drawGrid();
    }
  });

  // Initial load
  loadGrid();
</script>
</body>
</html>
