<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Invisible Million</title>
<style>
  /* Reset & basics */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0; height: 100vh; overflow: hidden; 
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
  }
  a {
    color: #4eaaff;
    text-decoration: none;
  }
  a:hover {
    text-decoration: underline;
  }

  /* Layout */
  #container {
    display: flex;
    height: 100vh;
    width: 100vw;
  }
  #sidebar {
    width: 250px;
    background: #222;
    border-right: 1px solid #444;
    display: flex;
    flex-direction: column;
    padding: 10px;
  }
  #sidebar h2 {
    margin: 0 0 10px 0;
    font-weight: normal;
    font-size: 20px;
  }
  #links {
    margin-bottom: 15px;
  }
  #links a {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
  }

  /* Minimap container inside sidebar */
  #minimap-container {
    flex-grow: 1;
    background: #000;
    border: 1px solid #444;
    position: relative;
  }

  /* Main area */
  #main {
    flex-grow: 1;
    background: #111;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* Top bar with donation + fullscreen */
  #topbar {
    background: #222;
    padding: 8px 12px;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    border-bottom: 1px solid #444;
  }
  button {
    background: #4eaaff;
    border: none;
    color: white;
    padding: 6px 14px;
    font-size: 14px;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover {
    background: #357ab7;
  }

  /* Grid container with zoom & pan */
  #grid-container {
    flex-grow: 1;
    overflow: hidden;
    position: relative;
    touch-action: none;
    background: #222;
  }
  #grid {
    position: absolute;
    top: 0; left: 0;
    transform-origin: 0 0;
    image-rendering: pixelated;
  }
  /* Each square */
  .square {
    width: 10px;
    height: 10px;
    box-sizing: border-box;
    border: 1px solid #222;
    float: left;
    user-select: none;
  }
</style>
</head>
<body>

<div id="container">

  <div id="sidebar">
    <h2>Menu</h2>
    <div id="links">
      <a href="page1.html" target="_blank">Static Page 1</a>
      <a href="page2.html" target="_blank">Static Page 2</a>
      <a href="page3.html" target="_blank">Static Page 3</a>
    </div>
    <div id="minimap-container"></div>
  </div>

  <div id="main">
    <div id="topbar">
      <button id="donateBtn">Donate</button>
      <button id="fullscreenBtn">Fullscreen</button>
    </div>
    <div id="grid-container">
      <div id="grid"></div>
    </div>
  </div>

</div>

<script>
(() => {
  // Constants
  const GRID_SIZE = 1000;  // 1000x1000 squares
  const SQUARE_SIZE = 10;  // 10px squares
  const MIN_ZOOM = 0.1;
  const MAX_ZOOM = 5;

  // DOM Elements
  const grid = document.getElementById('grid');
  const gridContainer = document.getElementById('grid-container');
  const minimapContainer = document.getElementById('minimap-container');
  const donateBtn = document.getElementById('donateBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');

  // State for main grid
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;
  let isDragging = false;
  let dragStart = null;

  // State for minimap
  const minimapScale = 0.05; // minimap is 5% scale of full grid
  const minimapWidth = GRID_SIZE * minimapScale;
  const minimapHeight = GRID_SIZE * minimapScale;

  // Store colors of squares (default black)
  const squares = new Array(GRID_SIZE * GRID_SIZE).fill('#222');

  // Generate grid squares (just a lightweight way)
  function createGrid() {
    // We cannot create 1 million divs â€” will kill browser.
    // Instead, use a canvas for performance.

    // Replace #grid content with a canvas
    const canvas = document.createElement('canvas');
    canvas.width = GRID_SIZE * SQUARE_SIZE;
    canvas.height = GRID_SIZE * SQUARE_SIZE;
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    grid.replaceWith(canvas);
    gridCanvas = canvas;
    gridCtx = canvas.getContext('2d');

    // Draw initial grid (black squares with faint grid lines)
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        gridCtx.fillStyle = squares[y * GRID_SIZE + x];
        gridCtx.fillRect(x * SQUARE_SIZE, y * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
        // gridCtx.strokeStyle = '#111';
        // gridCtx.strokeRect(x * SQUARE_SIZE, y * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      }
    }
  }

  // Minimap: Use canvas
  const minimapCanvas = document.createElement('canvas');
  minimapCanvas.width = minimapWidth;
  minimapCanvas.height = minimapHeight;
  minimapCanvas.style.width = '100%';
  minimapCanvas.style.height = 'auto';
  minimapCanvas.style.display = 'block';
  minimapContainer.appendChild(minimapCanvas);
  const minimapCtx = minimapCanvas.getContext('2d');

  // Draw minimap base (black)
  minimapCtx.fillStyle = '#000';
  minimapCtx.fillRect(0, 0, minimapWidth, minimapHeight);

  // Draw red viewport rectangle in minimap
  const viewportRect = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  };

  // Track dragging minimap viewport
  let minimapDragging = false;
  let minimapDragStart = null;

  // Initialize grid canvas
  let gridCanvas, gridCtx;
  createGrid();

  // Resize grid canvas container
  function resizeGridContainer() {
    const rect = gridContainer.getBoundingClientRect();
    gridCanvas.style.width = `${rect.width}px`;
    gridCanvas.style.height = `${rect.height}px`;
    updateGridTransform();
  }
  window.addEventListener('resize', resizeGridContainer);
  resizeGridContainer();

  // Apply transform to grid canvas for zoom and pan
  function updateGridTransform() {
    const transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoom})`;
    gridCanvas.style.transform = transform;
    updateMinimapViewport();
  }

  // Update minimap viewport rectangle position and size based on current zoom & pan
  function updateMinimapViewport() {
    const containerRect = gridContainer.getBoundingClientRect();

    // Viewport size in grid coordinates:
    const viewWidth = containerRect.width / zoom;
    const viewHeight = containerRect.height / zoom;

    viewportRect.x = -offsetX / zoom * minimapScale;
    viewportRect.y = -offsetY / zoom * minimapScale;
    viewportRect.width = viewWidth * minimapScale;
    viewportRect.height = viewHeight * minimapScale;

    drawMinimap();
  }

  // Draw minimap with viewport rectangle
  function drawMinimap() {
    // Clear minimap
    minimapCtx.clearRect(0, 0, minimapWidth, minimapHeight);

    // Draw background (black)
    minimapCtx.fillStyle = '#000';
    minimapCtx.fillRect(0, 0, minimapWidth, minimapHeight);

    // Draw viewport rectangle
    minimapCtx.strokeStyle = 'red';
    minimapCtx.lineWidth = 2;
    minimapCtx.fillStyle = 'rgba(255,0,0,0.2)';
    minimapCtx.fillRect(viewportRect.x, viewportRect.y, viewportRect.width, viewportRect.height);
    minimapCtx.strokeRect(viewportRect.x, viewportRect.y, viewportRect.width, viewportRect.height);
  }

  // Handle dragging on main grid for panning
  gridContainer.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart = { x: e.clientX, y: e.clientY, offsetX, offsetY };
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
    dragStart = null;
  });
  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    offsetX = dragStart.offsetX + dx;
    offsetY = dragStart.offsetY + dy;
    updateGridTransform();
  });

  // Handle zoom on wheel
  gridContainer.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = gridContainer.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wheel = e.deltaY < 0 ? 1.1 : 0.9;
    const newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoom * wheel));
    // Zoom towards mouse pointer
    offsetX -= (mouseX / zoom) * (newZoom - zoom);
    offsetY -= (mouseY / zoom) * (newZoom - zoom);
    zoom = newZoom;
    updateGridTransform();
  }, { passive: false });

  // Pinch to zoom support
  let pinchStartDist = 0;
  let pinchStartZoom = 1;

  gridContainer.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      pinchStartDist = getDistance(e.touches[0], e.touches[1]);
      pinchStartZoom = zoom;
    }
  });

  gridContainer.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const newDist = getDistance(e.touches[0], e.touches[1]);
      let newZoom = pinchStartZoom * (newDist / pinchStartDist);
      newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newZoom));
      zoom = newZoom;
      updateGridTransform();
    }
  }, { passive: false });

  function getDistance(t1, t2) {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Double tap for fullscreen toggle (mobile)
  let lastTap = 0;
  gridContainer.addEventListener('touchend', (e) => {
    const currentTime = Date.now();
    if (currentTime - lastTap < 300) {
      toggleFullscreen();
    }
    lastTap = currentTime;
  });

  // Fullscreen button
  fullscreenBtn.addEventListener('click', toggleFullscreen);

  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }

  // Minimap interaction - click or drag viewport rectangle
  minimapCanvas.addEventListener('mousedown', (e) => {
    const rect = minimapCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Check if click inside viewport rect
    if (
      x >= viewportRect.x && x <= viewportRect.x + viewportRect.width &&
      y >= viewportRect.y && y <= viewportRect.y + viewportRect.height
    ) {
      minimapDragging = true;
      minimapDragStart = { x, y, offsetX, offsetY };
    } else {
      // Click outside viewport rect - jump viewport
      moveViewportTo(x, y);
    }
  });
  window.addEventListener('mouseup', () => {
    minimapDragging = false;
    minimapDragStart = null;
  });
  minimapCanvas.addEventListener('mousemove', (e) => {
    if (!minimapDragging) return;
    const rect = minimapCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const dx = x - minimapDragStart.x;
    const dy = y - minimapDragStart.y;

    // Calculate new offsetX and offsetY based on drag delta
    // Remember offsetX/Y are in pixels scaled by zoom
    const moveX = -dx / minimapScale * zoom;
    const moveY = -dy / minimapScale * zoom;

    offsetX = minimapDragStart.offsetX + moveX;
    offsetY = minimapDragStart.offsetY + moveY;
    updateGridTransform();
  });

  // Click outside viewport rectangle on minimap moves viewport centered on click
  function moveViewportTo(minimapX, minimapY) {
    const containerRect = gridContainer.getBoundingClientRect();
    const viewWidth = containerRect.width / zoom;
    const viewHeight = containerRect.height / zoom;

    // Calculate new offsetX, offsetY to center viewport at click
    offsetX = -(minimapX / minimapScale) * zoom + containerRect.width / 2;
    offsetY = -(minimapY / minimapScale) * zoom + containerRect.height / 2;

    updateGridTransform();
  }

  // Donate button handler (placeholder)
  donateBtn.addEventListener('click', () => {
    alert('Donation system coming soon!');
  });

  // Initial update
  updateGridTransform();
})();
</script>

</body>
</html>
