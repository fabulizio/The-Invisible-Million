<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Invisible Million</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
    }
    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #minimap {
      margin-top: 10px;
      border: 1px solid #444;
      cursor: pointer;
    }
    #canvasWrapper {
      position: relative;
    }
    canvas {
      border: 1px solid #333;
      touch-action: none;
    }
    #coords {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    #zoomControls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
    }
    #zoomControls button {
      margin: 2px;
      background: #222;
      border: none;
      color: white;
      padding: 8px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 4px;
    }
    #colorPicker {
      position: absolute;
      display: none;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="minimap" width="200" height="200"></canvas>
    <div id="canvasWrapper">
      <canvas id="grid" width="800" height="800"></canvas>
      <div id="coords">x: –, y: –</div>
      <div id="zoomControls">
        <button id="zoomIn">+</button>
        <button id="zoomOut">−</button>
        <button id="fullscreen">⛶</button>
      </div>
    </div>
  </div>
  <input type="color" id="colorPicker" />
  
  <script>
    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d');
    const minimap = document.getElementById('minimap');
    const minimapCtx = minimap.getContext('2d');
    const coordsDisplay = document.getElementById('coords');
    const colorPicker = document.getElementById('colorPicker');
    const ZOOM_STEP = 2;
    const GRID_SIZE = 1000;
    const CANVAS_SIZE = 800;
    const MIN_ZOOM = 4;
    const MAX_ZOOM = 100;
    const SCALE_FACTOR = minimap.width / GRID_SIZE;

    let zoom = 20;
    let offsetX = 0;
    let offsetY = 0;
    let gridData = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill('#111'));

    function drawGrid() {
      const cellSize = CANVAS_SIZE / zoom;
      ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      for (let x = 0; x < zoom; x++) {
        for (let y = 0; y < zoom; y++) {
          const gridX = Math.floor(offsetX + x);
          const gridY = Math.floor(offsetY + y);
          if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
            ctx.fillStyle = gridData[gridX][gridY];
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }
      }
    }

    function drawMinimap() {
      const w = minimap.width;
      const h = minimap.height;
      minimapCtx.clearRect(0, 0, w, h);

      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          minimapCtx.fillStyle = gridData[x][y];
          minimapCtx.fillRect(x * SCALE_FACTOR, y * SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
        }
      }

      const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
      const boxX = offsetX * SCALE_FACTOR;
      const boxY = offsetY * SCALE_FACTOR;
      const boxSize = visibleSquares * SCALE_FACTOR;

      minimapCtx.strokeStyle = 'red';
      minimapCtx.lineWidth = 1;
      minimapCtx.strokeRect(boxX, boxY, boxSize, boxSize);
    }

    function clampOffsets() {
      const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
      offsetX = Math.max(0, Math.min(GRID_SIZE - visibleSquares, offsetX));
      offsetY = Math.max(0, Math.min(GRID_SIZE - visibleSquares, offsetY));
    }

    function coordsFromPixel(px, py) {
      const cellSize = CANVAS_SIZE / zoom;
      const x = Math.floor(px / cellSize + offsetX);
      const y = Math.floor(py / cellSize + offsetY);
      return { x, y };
    }

    function showCoordsDisplay({ x, y }) {
      if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
        coordsDisplay.textContent = `x: ${x}, y: ${y}`;
      } else {
        coordsDisplay.textContent = 'x: –, y: –';
      }
    }

    function onCanvasClick(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const { x, y } = coordsFromPixel(mouseX, mouseY);
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;

      colorPicker.style.left = `${e.pageX}px`;
      colorPicker.style.top = `${e.pageY}px`;
      colorPicker.value = gridData[x][y];
      colorPicker.style.display = 'block';

      colorPicker.oninput = () => {
        gridData[x][y] = colorPicker.value;
        drawGrid();
        drawMinimap();
      };

      colorPicker.onblur = () => {
        colorPicker.style.display = 'none';
      };

      colorPicker.focus();
    }

    document.getElementById('zoomIn').onclick = () => {
      zoom = Math.min(zoom + ZOOM_STEP, MAX_ZOOM);
      clampOffsets();
      drawGrid();
      drawMinimap();
    };

    document.getElementById('zoomOut').onclick = () => {
      zoom = Math.max(zoom - ZOOM_STEP, MIN_ZOOM);
      clampOffsets();
      drawGrid();
      drawMinimap();
    };

    document.getElementById('fullscreen').onclick = () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        canvas.parentElement.requestFullscreen();
      }
    };

    minimap.addEventListener('click', e => {
      const rect = minimap.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
      offsetX = (clickX * SCALE_FACTOR) - visibleSquares / 2;
      offsetY = (clickY * SCALE_FACTOR) - visibleSquares / 2;
      clampOffsets();
      drawGrid();
      drawMinimap();
    });

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      showCoordsDisplay(coordsFromPixel(mouseX, mouseY));
    });

    canvas.addEventListener('mouseleave', () => showCoordsDisplay({ x: -1, y: -1 }));
    canvas.addEventListener('click', onCanvasClick);

    // Mobile gestures
    let lastTouchDist = null;
    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        lastTouchDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
      }
    });

    canvas.addEventListener('touchmove', e => {
      if (e.touches.length === 2 && lastTouchDist) {
        const newDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        if (newDist > lastTouchDist + 10) {
          zoom = Math.min(zoom + ZOOM_STEP, MAX_ZOOM);
          lastTouchDist = newDist;
        } else if (newDist < lastTouchDist - 10) {
          zoom = Math.max(zoom - ZOOM_STEP, MIN_ZOOM);
          lastTouchDist = newDist;
        }
        clampOffsets();
        drawGrid();
        drawMinimap();
      }
    });

    canvas.addEventListener('touchend', e => {
      if (e.touches.length < 2) {
        lastTouchDist = null;
      }
    });

    // Doppio tap per fullscreen
    let lastTap = 0;
    canvas.addEventListener('touchend', e => {
      const now = Date.now();
      if (now - lastTap < 300) {
        document.getElementById('fullscreen').click();
      }
      lastTap = now;
    });

    function fetchGridData() {
      // dummy fill per esempio
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          gridData[x][y] = '#111';
        }
      }
      drawGrid();
      drawMinimap();
    }

    fetchGridData();
    setInterval(fetchGridData, 10000);
  </script>
</body>
</html>
