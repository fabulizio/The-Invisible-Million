<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Invisible Million</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      max-width: 600px;
      padding: 1.5rem;
      text-align: center;
    }

    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-bottom: 30px;
    }

    #minimap-container,
    #mainframe {
      position: relative;
      width: 300px;
      height: 300px;
      border: 3px solid white;
      background-color: #ddd;
      touch-action: none;
    }

    @media (max-width: 900px) {
      #minimap-container,
      #mainframe {
        width: 90vw;
        height: 90vw;
        touch-action: pinch-zoom;
      }

      #container {
        padding-left: 5vw;
        padding-right: 5vw;
      }
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: default;
      image-rendering: pixelated;
      background-color: #ddd;
    }

    #viewport-box {
      position: absolute;
      border: 2px solid red;
      pointer-events: none;
      background: rgba(255, 0, 0, 0.15);
    }

    #colorModal {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      padding: 20px 25px;
      border-radius: 8px;
      box-shadow: 0 0 15px #ff4444cc;
      color: #fff;
      user-select: none;
      text-align: center;
      min-width: 250px;
    }

    #colorModal h2 {
      margin: 0 0 10px;
      font-weight: normal;
    }

    #colorPicker {
      width: 100%;
      height: 40px;
      border: none;
      background-color: transparent;
      margin-bottom: 15px;
    }

    #colorModal button {
      background-color: #ff4444;
      border: none;
      padding: 8px 20px;
      color: white;
      font-weight: bold;
      border-radius: 5px;
      margin: 0 10px;
      transition: background-color 0.2s ease;
    }

    #colorModal button:hover {
      background-color: #cc0000;
    }

    #counter {
      font-size: 1.2rem;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <header>
    <h1>The Invisible Million</h1>
    <p>Zoom, esplora e colora un quadrato sulla griglia invisibile da un milione di celle!</p>
    <div id="counter">Loading painted squares...</div>
  </header>

  <div id="container">
    <div id="minimap-container">
      <canvas id="minimap"></canvas>
      <div id="viewport-box"></div>
    </div>
    <div id="mainframe">
      <canvas id="mainCanvas"></canvas>
    </div>
  </div>

  <div id="colorModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <h2 id="modalTitle">Scegli un colore</h2>
    <input type="color" id="colorPicker" value="#ff0000" />
    <div>
      <button id="cancelBtn">Annulla</button>
      <button id="okBtn">OK</button>
    </div>
  </div>

  <script>
    const BACKEND_URL = "https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev";
    const GRID_SIZE = 1000;

    const CANVAS_SIZE = window.innerWidth <= 900 ? Math.floor(window.innerWidth * 0.9) : 300;
    const MINIMAP_SIZE = CANVAS_SIZE;
    const SCALE_FACTOR = GRID_SIZE / MINIMAP_SIZE;

    let zoom = parseFloat(localStorage.getItem("zoom")) || 5;
    let offsetX = parseFloat(localStorage.getItem("offsetX")) || 0;
    let offsetY = parseFloat(localStorage.getItem("offsetY")) || 0;

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = CANVAS_SIZE;
    canvas.height = CANVAS_SIZE;

    const minimap = document.getElementById('minimap');
    const miniCtx = minimap.getContext('2d');
    minimap.width = MINIMAP_SIZE;
    minimap.height = MINIMAP_SIZE;

    const viewportBox = document.getElementById('viewport-box');
    const counter = document.getElementById('counter');

    let gridData = {};
    let selectedSquare = null;

    function clampOffsets() {
      const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
      offsetX = Math.min(Math.max(offsetX, 0), GRID_SIZE - visibleSquares);
      offsetY = Math.min(Math.max(offsetY, 0), GRID_SIZE - visibleSquares);
    }

    function drawGrid() {
      ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
      const pixelSize = zoom;
      const visibleSquares = Math.floor(CANVAS_SIZE / pixelSize);

      clampOffsets();

      ctx.fillStyle = '#ddd';
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x <= visibleSquares; x++) {
        const px = x * pixelSize;
        ctx.moveTo(px, 0);
        ctx.lineTo(px, visibleSquares * pixelSize);
      }
      for (let y = 0; y <= visibleSquares; y++) {
        const py = y * pixelSize;
        ctx.moveTo(0, py);
        ctx.lineTo(visibleSquares * pixelSize, py);
      }
      ctx.stroke();

      for (let x = 0; x < visibleSquares; x++) {
        for (let y = 0; y < visibleSquares; y++) {
          const gridX = Math.floor(offsetX) + x;
          const gridY = Math.floor(offsetY) + y;
          const key = `${gridX},${gridY}`;
          if (gridData[key]) {
            ctx.fillStyle = gridData[key].color;
            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
          }
        }
      }

      if (selectedSquare) {
        const selX = selectedSquare.x - Math.floor(offsetX);
        const selY = selectedSquare.y - Math.floor(offsetY);
        if (selX >= 0 && selX < visibleSquares && selY >= 0 && selY < visibleSquares) {
          ctx.strokeStyle = 'yellow';
          ctx.lineWidth = 3;
          ctx.strokeRect(selX * pixelSize, selY * pixelSize, pixelSize, pixelSize);
        }
      }
    }

    function drawMinimap() {
      miniCtx.clearRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
      miniCtx.fillStyle = '#ddd';
      miniCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

      for (const key in gridData) {
        const [x, y] = key.split(',').map(Number);
        miniCtx.fillStyle = gridData[key].color;
        miniCtx.fillRect(x / SCALE_FACTOR, y / SCALE_FACTOR, 1 / SCALE_FACTOR, 1 / SCALE_FACTOR);
      }

      const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
      const scale = MINIMAP_SIZE / GRID_SIZE;
      const boxWidth = visibleSquares * scale;
      const boxHeight = visibleSquares * scale;
      const boxLeft = offsetX * scale;
      const boxTop = offsetY * scale;

      viewportBox.style.width = `${boxWidth}px`;
      viewportBox.style.height = `${boxHeight}px`;
      viewportBox.style.left = `${boxLeft}px`;
      viewportBox.style.top = `${boxTop}px`;
    }

    function render() {
      drawGrid();
      drawMinimap();
      localStorage.setItem("zoom", zoom);
      localStorage.setItem("offsetX", offsetX);
      localStorage.setItem("offsetY", offsetY);
    }

    function openColorModal(x, y) {
      selectedSquare = { x, y };
      colorPicker.value = gridData[`${x},${y}`]?.color || '#ff0000';
      colorModal.style.display = 'block';
      colorPicker.focus();
    }

    function closeColorModal() {
      colorModal.style.display = 'none';
      selectedSquare = null;
    }

    function paintSquare(x, y, color) {
      fetch(`${BACKEND_URL}/paint`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ x, y, color })
      })
      .then(res => res.json())
      .then(data => {
        if(data.success) {
          gridData[`${x},${y}`] = { color };
          counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
          render();
          closeColorModal();
        } else {
          alert(data.error || 'Errore nella pittura');
          closeColorModal();
        }
      })
      .catch(() => {
        alert('Errore di rete');
        closeColorModal();
      });
    }

    fetch(`${BACKEND_URL}/painted`)
      .then(res => res.json())
      .then(data => {
        gridData = data;
        counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
        render();
      })
      .catch(() => {
        counter.textContent = "Errore nel caricamento dei dati.";
      });

    document.getElementById('mainframe').addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const oldZoom = zoom;
      const delta = e.deltaY > 0 ? -0.5 : 0.5;
      zoom = Math.min(20, Math.max(1, zoom + delta));
      offsetX += mx / oldZoom - mx / zoom;
      offsetY += my / oldZoom - my / zoom;
      render();
    }, { passive: false });

    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
    });
    window.addEventListener('mouseup', () => {
      isDragging = false;
    });
    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = (dragStart.x - e.clientX) / zoom;
      const dy = (dragStart.y - e.clientY) / zoom;
      offsetX = Math.min(Math.max(offsetX + dx, 0), GRID_SIZE - CANVAS_SIZE / zoom);
      offsetY = Math.min(Math.max(offsetY + dy, 0), GRID_SIZE - CANVAS_SIZE / zoom);
      dragStart = { x: e.clientX, y: e.clientY };
      render();
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      const x = Math.floor(offsetX + px / zoom);
      const y = Math.floor(offsetY + py / zoom);
      const key = `${x},${y}`;
      if(gridData[key]) return;
      openColorModal(x, y);
    });

    const colorModal = document.getElementById('colorModal');
    const colorPicker = document.getElementById('colorPicker');
    const okBtn = document.getElementById('okBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    okBtn.addEventListener('click', () => {
      if (!selectedSquare) return closeColorModal();
      const color = colorPicker.value;
      paintSquare(selectedSquare.x, selectedSquare.y, color);
    });

    cancelBtn.addEventListener('click', () => {
      closeColorModal();
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && colorModal.style.display === 'block') {
        closeColorModal();
      }
    });

    render();
  </script>
</body>
</html>
