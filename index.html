<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>The Invisible Million</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }
    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    #minimap-container,
    #mainframe {
      position: relative;
      width: 800px;
      height: 800px;
      background: #ddd;
      border: 3px solid #fff;
      margin-bottom: 20px;
    }
    #mainCanvas {
      position: absolute;
      width: 100%;
      height: 100%;
      cursor: default;
      image-rendering: pixelated;
    }
    #minimap {
      position: absolute;
      width: 100%;
      height: 100%;
      cursor: grab;
      image-rendering: pixelated;
    }
    #viewport-box {
      position: absolute;
      border: 2px solid red;
      background: rgba(255,0,0,0.15);
      pointer-events: none;
    }
    #colorModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: #222;
      color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 15px #ff4444cc;
      text-align: center;
      min-width: 250px;
      z-index: 1000;
    }
    #colorModal input, #colorModal button {
      margin: 10px;
    }
    #counter {
      font-size: 1.2rem;
      margin-top: 10px;
    }
    @media (max-width: 900px) {
      #minimap-container, #mainframe {
        width: 90vw;
        height: 90vw;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <header>
      <h1>The Invisible Million</h1>
      <p>IL MIO MANIFESTO QUI</p>
      <div id="counter">Loading painted squares...</div>
    </header>
    <div id="minimap-container">
      <canvas id="minimap" width="800" height="800"></canvas>
      <div id="viewport-box"></div>
    </div>
    <div id="mainframe">
      <canvas id="mainCanvas" width="800" height="800"></canvas>
    </div>
  </div>

  <div id="colorModal" role="dialog" aria-modal="true">
    <h2>Scegli un colore</h2>
    <input type="color" id="colorPicker" value="#ff0000" />
    <div>
      <button id="cancelBtn">Annulla</button>
      <button id="okBtn">OK</button>
    </div>
  </div>

  <script>
    const BACKEND_URL = "https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev";
    const GRID_SIZE = 1000;
    const CANVAS_SIZE = 800;
    const SCALE_FACTOR = GRID_SIZE / CANVAS_SIZE;

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const minimap = document.getElementById('minimap');
    const miniCtx = minimap.getContext('2d');
    const viewportBox = document.getElementById('viewport-box');
    const counter = document.getElementById('counter');
    const colorModal = document.getElementById('colorModal');
    const colorPicker = document.getElementById('colorPicker');
    const okBtn = document.getElementById('okBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    ctx.imageSmoothingEnabled = miniCtx.imageSmoothingEnabled = false;

    let gridData = {};
    let selectedSquare = null;
    let zoom = parseFloat(localStorage.getItem("zoom")) || 5;
    let offsetX = parseFloat(localStorage.getItem("offsetX")) || 0;
    let offsetY = parseFloat(localStorage.getItem("offsetY")) || 0;

    function clampOffsets() {
      const vs = Math.floor(CANVAS_SIZE / zoom);
      offsetX = Math.min(Math.max(offsetX, 0), GRID_SIZE - vs);
      offsetY = Math.min(Math.max(offsetY, 0), GRID_SIZE - vs);
    }

    function drawGrid() {
      ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
      const ps = zoom;
      const vs = Math.floor(CANVAS_SIZE / ps);
      clampOffsets();

      ctx.fillStyle = "#ddd";
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
      ctx.strokeStyle = "#bbb";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 0; i <= vs; i++) {
        ctx.moveTo(i * ps, 0);
        ctx.lineTo(i * ps, vs * ps);
        ctx.moveTo(0, i * ps);
        ctx.lineTo(vs * ps, i * ps);
      }
      ctx.stroke();

      for (let x = 0; x < vs; x++) {
        for (let y = 0; y < vs; y++) {
          const gx = Math.floor(offsetX) + x;
          const gy = Math.floor(offsetY) + y;
          const key = `${gx},${gy}`;
          if (gridData[key]) {
            ctx.fillStyle = gridData[key].color;
            ctx.fillRect(x * ps, y * ps, ps, ps);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.strokeRect(x * ps, y * ps, ps, ps);
          }
        }
      }

      if (selectedSquare) {
        const sx = selectedSquare.x - offsetX;
        const sy = selectedSquare.y - offsetY;
        if (sx >= 0 && sy >= 0 && sx < vs && sy < vs) {
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 3;
          ctx.strokeRect(sx * ps, sy * ps, ps, ps);
        }
      }
    }

    function drawMinimap() {
      miniCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
      miniCtx.fillStyle = "#ddd";
      miniCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
      for (const key in gridData) {
        const [x, y] = key.split(',').map(Number);
        miniCtx.fillStyle = gridData[key].color;
        miniCtx.fillRect(x / SCALE_FACTOR, y / SCALE_FACTOR, 1 / SCALE_FACTOR, 1 / SCALE_FACTOR);
      }
      const vs = Math.floor(CANVAS_SIZE / zoom);
      const scale = CANVAS_SIZE / GRID_SIZE;
      const bw = vs * scale;
      const bh = vs * scale;
      viewportBox.style.width = bw + "px";
      viewportBox.style.height = bh + "px";
      viewportBox.style.left = offsetX * scale + "px";
      viewportBox.style.top = offsetY * scale + "px";
    }

    function render() {
      drawGrid();
      drawMinimap();
      localStorage.setItem("zoom", zoom);
      localStorage.setItem("offsetX", offsetX);
      localStorage.setItem("offsetY", offsetY);
    }

    function openColorModal(x, y) {
      selectedSquare = { x, y };
      colorPicker.value = gridData[`${x},${y}`]?.color || "#ff0000";
      colorModal.style.display = "block";
      colorPicker.focus();
    }
    function closeColorModal() {
      colorModal.style.display = "none";
      selectedSquare = null;
    }
    function paintSquare(x, y, color) {
      fetch(`${BACKEND_URL}/paint`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ x, y, color })
      })
        .then(r => r.json())
        .then(d => {
          if (d.success) {
            gridData[`${x},${y}`] = { color };
            counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
            render();
            closeColorModal();
          } else {
            alert(d.error || "Errore pittura");
          }
        })
        .catch(() => alert("Errore rete"));
    }

    fetch(`${BACKEND_URL}/painted`)
      .then(r => r.json())
      .then(d => {
        gridData = d;
        counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
        render();
      })
      .catch(() => counter.textContent = "Errore caricamento");

    document.getElementById('mainframe').addEventListener('wheel', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const old = zoom;
      zoom = Math.min(20, Math.max(1, zoom + (e.deltaY > 0 ? -0.5 : 0.5)));
      offsetX += mx / old - mx / zoom;
      offsetY += my / old - my / zoom;
      render();
    }, { passive: false });

    let isDragging = false, dstart = {};
    canvas.addEventListener('mousedown', e => {
      isDragging = true;
      dstart = { x: e.clientX, y: e.clientY };
    });
    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      offsetX += (dstart.x - e.clientX) / zoom;
      offsetY += (dstart.y - e.clientY) / zoom;
      dstart = { x: e.clientX, y: e.clientY };
      render();
    });

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor(offsetX + (e.clientX - rect.left) / zoom);
      const y = Math.floor(offsetY + (e.clientY - rect.top) / zoom);
      openColorModal(x, y);
    });

    cancelBtn.addEventListener('click', closeColorModal);
    okBtn.addEventListener('click', () => {
      if (selectedSquare) paintSquare(selectedSquare.x, selectedSquare.y, colorPicker.value);
    });

    let minimapDragging = false;
    minimap.addEventListener('mousedown', e => {
      minimapDragging = true;
      minimap.style.cursor = 'grabbing';
    });
    window.addEventListener('mouseup', () => {
      minimapDragging = false;
      minimap.style.cursor = 'grab';
    });
    window.addEventListener('mousemove', e => {
      if (!minimapDragging) return;
      const rect = minimap.getBoundingClientRect();
      let mx = e.clientX - rect.left;
      let my = e.clientY - rect.top;
      const vs = Math.floor(CANVAS_SIZE / zoom);
      const scale = CANVAS_SIZE / GRID_SIZE;
      const bw = vs * scale, bh = vs * scale;
      mx = Math.min(Math.max(mx, 0), CANVAS_SIZE - bw);
      my = Math.min(Math.max(my, 0), CANVAS_SIZE - bh);
      offsetX = mx / scale;
      offsetY = my / scale;
      render();
    });
    minimap.addEventListener('click', e => {
      if (minimapDragging) return;
      const rect = minimap.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const vs = Math.floor(CANVAS_SIZE / zoom);
      const scale = CANVAS_SIZE / GRID_SIZE;
      offsetX = Math.min(Math.max(mx / scale - vs / 2, 0), GRID_SIZE - vs);
      offsetY = Math.min(Math.max(my / scale - vs / 2, 0), GRID_SIZE - vs);
      render();
    });

    // Disabilita pinch-to-zoom mobile
    document.addEventListener('touchstart', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
    document.addEventListener('touchmove', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });

    window.addEventListener('keydown', e => {
      if (e.key === '+') { zoom = Math.min(20, zoom + 1); render(); }
      else if (e.key === '-') { zoom = Math.max(1, zoom - 1); render(); }
    });

  </script>
</body>
</html>
