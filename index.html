<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>The Invisible Million</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      touch-action: none;
    }
    #zoom-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 20;
    }
    #zoom-controls button {
      background: rgba(255,255,255,0.8);
      border: none;
      font-size: 20px;
      padding: 5px;
      cursor: pointer;
      border-radius: 5px;
    }
    #color-picker {
      position: absolute;
      display: none;
      z-index: 30;
      background: #fff;
      border: 1px solid #000;
      padding: 10px;
      border-radius: 8px;
    }
    #minimap {
      position: absolute;
      top: 10px;
      right: 10px;
      border: 2px solid white;
      background: rgba(0, 0, 0, 0.3);
      z-index: 10;
      image-rendering: pixelated;
    }
    #coords {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 4px 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
      z-index: 20;
    }
  </style>
</head>
<body>
  <canvas id="main-canvas"></canvas>
  <canvas id="minimap" width="200" height="200"></canvas>
  <div id="zoom-controls">
    <button onclick="zoomIn()">+</button>
    <button onclick="zoomOut()">âˆ’</button>
  </div>
  <div id="color-picker">
    <input type="color" id="color-input" value="#ff0000">
  </div>
  <div id="coords">0,0</div>

  <script>
    const canvas = document.getElementById("main-canvas");
    const ctx = canvas.getContext("2d");
    const minimap = document.getElementById("minimap");
    const mCtx = minimap.getContext("2d");
    const picker = document.getElementById("color-picker");
    const colorInput = document.getElementById("color-input");
    const coordsBox = document.getElementById("coords");

    let cellSize = 10;
    let offsetX = 0;
    let offsetY = 0;
    let dragging = false;
    let dragStart = {};
    let currentColor = "#ff0000";
    let grid = {}; // "x,y": "#rrggbb"
    const gridSize = 1000;

    const ws = new WebSocket("wss://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev:8765");

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === "state") {
        grid = data.coloredSquares || {};
        draw();
      } else if (data.type === "color_update") {
        const key = `${data.x},${data.y}`;
        grid[key] = { color: data.color };
        draw();
      }
    };

    ws.onopen = () => ws.send(JSON.stringify({ type: "request_state" }));

    function draw() {
      resizeCanvas();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const key in grid) {
        const [x, y] = key.split(",").map(Number);
        const px = x * cellSize - offsetX;
        const py = y * cellSize - offsetY;
        if (
          px + cellSize >= 0 && px < canvas.width &&
          py + cellSize >= 0 && py < canvas.height
        ) {
          ctx.fillStyle = grid[key].color;
          ctx.fillRect(px, py, cellSize, cellSize);
        }
      }

      drawMinimap();
    }

    function drawMinimap() {
      mCtx.clearRect(0, 0, minimap.width, minimap.height);
      const scale = minimap.width / gridSize;

      for (const key in grid) {
        const [x, y] = key.split(",").map(Number);
        mCtx.fillStyle = grid[key].color;
        mCtx.fillRect(x * scale, y * scale, 1, 1);
      }

      // Draw viewport rectangle
      mCtx.strokeStyle = "red";
      mCtx.lineWidth = 1;
      mCtx.strokeRect(
        offsetX * scale / cellSize,
        offsetY * scale / cellSize,
        minimap.width * (canvas.width / (gridSize * cellSize)),
        minimap.height * (canvas.height / (gridSize * cellSize))
      );
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function zoomIn() {
      cellSize = Math.min(100, cellSize * 1.25);
      draw();
    }

    function zoomOut() {
      cellSize = Math.max(2, cellSize / 1.25);
      draw();
    }

    canvas.addEventListener("mousedown", (e) => {
      dragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
    });

    canvas.addEventListener("mousemove", (e) => {
      if (dragging) {
        offsetX -= e.clientX - dragStart.x;
        offsetY -= e.clientY - dragStart.y;
        dragStart.x = e.clientX;
        dragStart.y = e.clientY;
        draw();
      }

      const gridX = Math.floor((e.clientX + offsetX) / cellSize);
      const gridY = Math.floor((e.clientY + offsetY) / cellSize);
      coordsBox.textContent = `${gridX},${gridY}`;
    });

    canvas.addEventListener("mouseup", () => dragging = false);
    canvas.addEventListener("mouseleave", () => dragging = false);

    canvas.addEventListener("click", (e) => {
      const x = Math.floor((e.clientX + offsetX) / cellSize);
      const y = Math.floor((e.clientY + offsetY) / cellSize);
      if (grid[`${x},${y}`]) return;

      picker.style.left = `${e.clientX}px`;
      picker.style.top = `${e.clientY}px`;
      picker.style.display = "block";

      colorInput.onchange = () => {
        currentColor = colorInput.value;
        picker.style.display = "none";
        fetch("https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev/paint", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ x, y, color: currentColor })
        });
      };
    });

    minimap.addEventListener("click", (e) => {
      const rect = minimap.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const scale = gridSize / minimap.width;
      offsetX = mx * scale * cellSize - canvas.width / 2;
      offsetY = my * scale * cellSize - canvas.height / 2;
      draw();
    });

    // Zoom mobile pinch
    let lastDist = 0;
    canvas.addEventListener("touchstart", e => {
      if (e.touches.length === 2) {
        lastDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
      }
    });

    canvas.addEventListener("touchmove", e => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const newDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        if (Math.abs(newDist - lastDist) > 5) {
          if (newDist > lastDist) zoomIn(); else zoomOut();
          lastDist = newDist;
        }
      }
    }, { passive: false });

    // Double tap for fullscreen
    let lastTap = 0;
    canvas.addEventListener("touchend", (e) => {
      const now = new Date().getTime();
      if (now - lastTap < 300) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
      lastTap = now;
    });

    window.addEventListener("resize", draw);
    draw();
  </script>
</body>
</html>
