<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The (In)Visible Million Project</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* ... [Keep all previous styles except palette-error; see below for changes] ... */
    /* Only palette-error styles are replaced below */
    .palette-error {
      position: fixed;
      left: 0;
      top: 0;
      z-index: 10001;
      display: none;
      font-size: 2em;
      font-weight: bold;
      padding: 18px 38px;
      border-radius: 16px;
      box-shadow: 0 0 22px #000;
      outline: 4px solid;
      text-align: center;
      pointer-events: none;
      transition: background .2s, color .2s, outline-color .2s;
    }
    /* ... [other styles remain unchanged, you can reuse your previous ones] ... */
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <span class="big-title">The (In)Visible Million Project</span>
      <div class="menu-icon" id="menuIcon" title="Menu" tabindex="0">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </div>
  </header>
  <main>
    <div style="position:relative">
      <div id="frame" tabindex="0">
        <canvas id="gridCanvas"></canvas>
        <div id="coordPopup"></div>
        <div class="nav-panel">
          <!-- ... [navigation buttons as before] ... -->
        </div>
        <div id="colorPickerModal" class="color-picker-modal">
          <canvas id="colorDisc" width="228" height="228"></canvas>
          <div class="modal-btns">
            <button id="randomColorBtn" type="button" class="fancy-btn">Random</button>
            <button id="confirmColorBtn" type="button" class="fancy-btn">OK</button>
            <button id="cancelColorBtn" type="button" class="fancy-btn">Cancel</button>
          </div>
        </div>
        <div class="palette-error" id="paletteError"></div>
        <div id="congratsMessage"></div>
      </div>
    </div>
    <div class="popup-menu" id="popupMenu">
      <!-- ... [menu links as before] ... -->
    </div>
    <footer>
      <!-- ... [footer as before] ... -->
    </footer>
  </main>
  <script>
    /***************************************************
     * Constants and State
     ***************************************************/
    const GRID_SIZE = 1100;
    const CELL_SIZE = 24;
    let zoom = 1;
    let MIN_ZOOM = 0.1;
    const MAX_ZOOM = 3;
    let offsetX = 0, offsetY = 0;
    let coloredCells = {};
    let redrawPending = false;
    let isDragging = false;
    let dragStart = {x: 0, y: 0};
    let offsetStart = {x: 0, y: 0};
    let palettePreviewCell = null;
    let showCursor = true;
    let hasDonated = false;
    let donationUsed = false;
    let pinch2Last = null;
    let pinch2Mode = null;
    let pinch2Origin = null;
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const frame = document.getElementById('frame');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const arrowUpBtn = document.getElementById('arrowUpBtn');
    const arrowDownBtn = document.getElementById('arrowDownBtn');
    const arrowLeftBtn = document.getElementById('arrowLeftBtn');
    const arrowRightBtn = document.getElementById('arrowRightBtn');
    const centerBtn = document.getElementById('centerBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const jumpX = document.getElementById('jumpX');
    const jumpY = document.getElementById('jumpY');
    const jumpBtn = document.getElementById('jumpBtn');
    const randomBtn = document.getElementById('randomBtn');
    const donateBtn = document.getElementById('donateBtn');
    const coordPopup = document.getElementById('coordPopup');
    const congratsMessage = document.getElementById('congratsMessage');
    const paletteError = document.getElementById('paletteError');
    const colorPickerModal = document.getElementById('colorPickerModal');
    const colorDisc = document.getElementById('colorDisc');
    const confirmColorBtn = document.getElementById('confirmColorBtn');
    const cancelColorBtn = document.getElementById('cancelColorBtn');
    const randomColorBtn = document.getElementById('randomColorBtn');
    let gridCursor = { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) };
    let previewColor = "#fff";

    /***************************************************
     * Utility Functions
     ***************************************************/
    function clampOffset() {
      const scaledCellSize = CELL_SIZE * zoom;
      const gridWidthPx = GRID_SIZE * scaledCellSize;
      const gridHeightPx = GRID_SIZE * scaledCellSize;
      offsetX = Math.min(0, Math.max(canvas.width - gridWidthPx, offsetX));
      offsetY = Math.min(0, Math.max(canvas.height - gridHeightPx, offsetY));
    }
    function pixelToCell(x, y) {
      const scaledCellSize = CELL_SIZE * zoom;
      const cellX = Math.floor((x - offsetX) / scaledCellSize);
      const cellY = Math.floor((y - offsetY) / scaledCellSize);
      return {x: cellX, y: cellY};
    }
    function getVisibleGridBounds() {
      const scaledCellSize = CELL_SIZE * zoom;
      const startCol = Math.floor(-offsetX / scaledCellSize);
      const startRow = Math.floor(-offsetY / scaledCellSize);
      const visibleCols = Math.ceil(canvas.width / scaledCellSize);
      const visibleRows = Math.ceil(canvas.height / scaledCellSize);
      return {
        left: Math.max(0, startCol),
        right: Math.min(GRID_SIZE - 1, startCol + visibleCols),
        top: Math.max(0, startRow),
        bottom: Math.min(GRID_SIZE - 1, startRow + visibleRows)
      };
    }

    /***************************************************
     * Dynamic Placement Logic
     ***************************************************/
    // Calculates whether "above" or "below" has more visible squares in the column
    function getPlacementForCell(cellX, cellY) {
      const bounds = getVisibleGridBounds();
      let above = cellY - bounds.top;
      let below = bounds.bottom - cellY;
      if (above >= below) return 'above';
      else return 'below';
    }
    // Generalized function for dynamic placement of modal/message
    function positionElementAboveBelow(element, cellX, cellY) {
      const bounds = getVisibleGridBounds();
      const scaledCellSize = CELL_SIZE * zoom;
      const frameRect = frame.getBoundingClientRect();

      const inFrameX = offsetX + cellX * scaledCellSize + scaledCellSize / 2;
      const inFrameY = offsetY + cellY * scaledCellSize + scaledCellSize / 2;
      let left = frameRect.left + inFrameX - element.offsetWidth / 2;
      let top;
      const placement = getPlacementForCell(cellX, cellY);
      if (placement === 'above') {
        top = frameRect.top + inFrameY - element.offsetHeight - 10;
        if (top < 0) top = frameRect.top + inFrameY + 10; // fallback if above is out of screen
      } else {
        top = frameRect.top + inFrameY + 10;
        if (top + element.offsetHeight > window.innerHeight)
          top = frameRect.top + inFrameY - element.offsetHeight - 10; // fallback
      }
      element.style.left = left + 'px';
      element.style.top = top + 'px';
    }

    /***************************************************
     * Palette Tool & Message Placement
     ***************************************************/
    function showColorPickerModalDynamic(cellX, cellY) {
      palettePreviewCell = {x: cellX, y: cellY};
      showCursor = true;
      requestRedraw();
      hideCoordPopup();
      colorPickerModal.style.background = previewColor || "#222";
      colorPickerModal.style.display = "flex";
      colorPickerModal.style.position = "fixed";
      colorPickerModal.style.width = "auto";
      colorPickerModal.style.height = "auto";
      // Wait for render so offsetHeight is correct
      setTimeout(() => positionElementAboveBelow(colorPickerModal, cellX, cellY), 1);
    }
    function showCongratsMessageDynamic(cellX, cellY) {
      congratsMessage.innerHTML = `ðŸŽ‰ Congratulations!<br>You have participated in The (In)Visible Million.<br>Thank you!<br><br>
      <span style="font-size:0.8em;">Proof of participation is saved in your browser's local storage.<br>
      See key <b>"invisibleMillionParticipation"</b> in <b>localStorage</b>.<br>
      (You can view this in your browser's developer tools > Application > Local Storage)</span>`;
      congratsMessage.style.display = "block";
      setTimeout(() => positionElementAboveBelow(congratsMessage, cellX, cellY), 1);
    }

    /***************************************************
     * "Square Already Colored" Message Styling
     ***************************************************/
    function showPaletteError(cellColor, mouseX, mouseY) {
      paletteError.textContent = "Square already colored! Please choose another empty square.";
      paletteError.style.display = "block";
      paletteError.style.background = cellColor;
      // Determine high-contrast color for text/outline
      let luminance = getLuminance(cellColor);
      let textColor = luminance > 0.5 ? "#111" : "#fff";
      let outlineColor = luminance > 0.5 ? "#222" : "#fff";
      paletteError.style.color = textColor;
      paletteError.style.outlineColor = outlineColor;
      // Position message centered above or below the colored square
      let cell = pixelToCell(mouseX - frame.getBoundingClientRect().left, mouseY - frame.getBoundingClientRect().top);
      setTimeout(() => positionElementAboveBelow(paletteError, cell.x, cell.y), 1);
      setTimeout(() => paletteError.style.display = "none", 2500);
    }
    // Utility: Get luminance for contrast calculation
    function getLuminance(hex) {
      let c = hex.substring(1); // remove #
      if (c.length === 3) c = c.split('').map(x => x + x).join('');
      let r = parseInt(c.substr(0,2),16)/255, g = parseInt(c.substr(2,2),16)/255, b = parseInt(c.substr(4,2),16)/255;
      return 0.2126*r + 0.7152*g + 0.0722*b;
    }

    /***************************************************
     * Main Grid Drawing and Event Handling
     ***************************************************/
    // ... [reuse your previous code for grid drawing, navigation, zoom, etc.]

    // Replace palette/modal show code
    canvas.addEventListener('click', (e) => {
      paletteError.style.display = "none";
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const cell = pixelToCell(mouseX, mouseY);
      gridCursor.x = Math.max(0, Math.min(GRID_SIZE - 1, cell.x));
      gridCursor.y = Math.max(0, Math.min(GRID_SIZE - 1, cell.y));
      jumpX.value = gridCursor.x;
      jumpY.value = gridCursor.y;
      ensureCellVisible(gridCursor.x, gridCursor.y);
      requestRedraw();
      const key = gridCursor.x + "," + gridCursor.y;
      if (coloredCells[key] && coloredCells[key].locked) {
        showPaletteError(coloredCells[key].color, e.clientX, e.clientY);
        return;
      }
      if (hasDonated && !donationUsed) showColorPickerModalDynamic(gridCursor.x, gridCursor.y);
    });

    // Confirm color button: show congrats message dynamically
    confirmColorBtn.onclick = function() {
      colorPickerModal.style.display = "none";
      showCursor = false;
      showCongratsMessageDynamic(gridCursor.x, gridCursor.y);
      const color = previewColor || "#fff";
      const key = gridCursor.x + "," + gridCursor.y;
      coloredCells[key] = {color: color, locked: true};
      sendCellColor(gridCursor.x, gridCursor.y, color);
      fetchGridState();
      palettePreviewCell = null;
      requestRedraw();
      saveParticipation();
      donationUsed = true;
      setTimeout(resetDonateButton, 5000);
    };
    
    cancelColorBtn.onclick = function() {
      hidePalette();
    };
    document.addEventListener('mousedown', function(e) {
      if (colorPickerModal.style.display === "flex" && !colorPickerModal.contains(e.target)) {
        hidePalette();
      }
      if (congratsMessage.style.display === "block" && !congratsMessage.contains(e.target)) {
        congratsMessage.style.display = "none";
        showCursor = true;
        requestRedraw();
      }
    });
    function placeCongratsMessageDynamic() {
      const scaledCellSize = CELL_SIZE * zoom;
      const frameRect = frame.getBoundingClientRect();
      const leftInFrame = offsetX + gridCursor.x * scaledCellSize + scaledCellSize / 2;
      const topInFrame = offsetY + gridCursor.y * scaledCellSize + scaledCellSize / 2;
      let mouseY = frameRect.top + topInFrame;
      let vpad = 10;
      let top;
      if (mouseY + congratsMessage.offsetHeight + vpad < window.innerHeight) {
        top = mouseY + vpad;
      } else {
        top = mouseY - congratsMessage.offsetHeight - vpad;
      }
      congratsMessage.innerHTML = `ðŸŽ‰ Congratulations!<br>You have participated in The (In)Visible Million.<br>Thank you!<br><br>
      <span style="font-size:0.8em;">Proof of participation is saved in your browser's local storage.<br>
      See key <b>"invisibleMillionParticipation"</b> in <b>localStorage</b>.<br>
      (You can view this in your browser's developer tools > Application > Local Storage)</span>`;
      congratsMessage.style.top = top + "px";
      congratsMessage.style.display = "block";
    }
    function saveParticipation() {
      localStorage.setItem("invisibleMillionParticipation", "true");
    }
    function checkParticipation() {}
    function resetDonateButton() {
      hasDonated = false;
      donationUsed = false;
      donateBtn.textContent = "Donate / Contribute";
    }
    donateBtn.onclick = function() {
      if (!hasDonated) {
        hasDonated = true;
        donationUsed = false;
        donateBtn.textContent = "Thanks for your support!";
        setTimeout(() => { 
          if (!donationUsed) donateBtn.textContent = "Donate / Contribute";
        }, 4000);
      }
    };
    function drawColorDisc() {
      const cx = colorDisc.width / 2;
      const cy = colorDisc.height / 2;
      const radius = colorDisc.width / 2 - 3;
      const ctxc = colorDisc.getContext('2d');
      ctxc.clearRect(0, 0, colorDisc.width, colorDisc.height);
      for (let angle=0; angle<360; angle+=1) {
        const rad = angle * Math.PI / 180;
        const grad = ctxc.createLinearGradient(
          cx, cy,
          cx + radius * Math.cos(rad), cy + radius * Math.sin(rad)
        );
        grad.addColorStop(0, 'white');
        grad.addColorStop(1, `hsl(${angle},100%,50%)`);
        ctxc.beginPath();
        ctxc.moveTo(cx, cy);
        ctxc.arc(cx, cy, radius, rad, rad+Math.PI/180, false);
        ctxc.closePath();
        ctxc.fillStyle = grad;
        ctxc.fill();
      }
      ctxc.globalAlpha = 0.3;
      ctxc.beginPath();
      ctxc.arc(cx, cy, radius, 0, 2*Math.PI);
      ctxc.fillStyle = 'black';
      ctxc.fill();
      ctxc.globalAlpha = 1.0;
    }
    drawColorDisc();
    function hsvToRgb(h, s, v) {
      let r, g, b;
      let i = Math.floor(h * 6);
      let f = h * 6 - i;
      let p = v * (1 - s);
      let q = v * (1 - f * s);
      let t = v * (1 - (1 - f) * s);
      switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
      }
      return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
    }
    function rgbToHex(r,g,b){
      return "#" + ((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
    }
    window.addEventListener('load', () => {
      setCanvasSize();
      frame.focus();
      zoomDisplay.textContent = Math.round(zoom * 100) + '%';
      fetchGridState();
      checkParticipation();
      requestRedraw();
    });
    window.addEventListener('resize', setCanvasSize);
  </script>
</body>
</html>
