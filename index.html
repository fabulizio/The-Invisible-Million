<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Invisible Million</title>
<style>
  body {
    margin: 0; padding: 0;
    font-family: Arial, sans-serif;
    background-color: #111;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  header {
    max-width: 600px;
    padding: 1.5rem;
    text-align: center;
  }
  #container {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
  }
  #minimap-container, #mainframe {
    position: relative;
    width: 400px;
    height: 400px;
    border: 3px solid white;
    background-color: #ddd;
  }
  canvas {
    position: absolute;
    top: 0; left: 0;
    cursor: grab;
    image-rendering: pixelated;
    background-color: #ddd;
  }
  #viewport-box {
    position: absolute;
    border: 2px solid red;
    pointer-events: none;
    background: rgba(255, 0, 0, 0.15);
  }
  #colorModal {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: #222;
    padding: 20px 25px;
    border-radius: 8px;
    box-shadow: 0 0 15px #ff4444cc;
    color: #fff;
    user-select: none;
    text-align: center;
    min-width: 250px;
  }
  #colorModal h2 {
    margin: 0 0 10px;
    font-weight: normal;
  }
  #colorPicker {
    width: 100%;
    height: 40px;
    border: none;
    cursor: pointer;
    background-color: transparent;
    margin-bottom: 15px;
  }
  #colorModal button {
    background-color: #ff4444;
    border: none;
    padding: 8px 20px;
    color: white;
    font-weight: bold;
    border-radius: 5px;
    cursor: pointer;
    margin: 0 10px;
    transition: background-color 0.2s ease;
  }
  #colorModal button:hover {
    background-color: #cc0000;
  }
  #counter {
    font-size: 1.2rem;
    margin-top: 10px;
  }
</style>
</head>
<body>
<header>
  <h1>The Invisible Million</h1>
  <p>Zoom, esplora e colora un quadrato sulla griglia invisibile da un milione di celle!</p>
  <div id="counter">Loading painted squares...</div>
</header>

<div id="container">
  <div id="minimap-container">
    <canvas id="minimap" width="400" height="400"></canvas>
    <div id="viewport-box"></div>
  </div>
  <div id="mainframe">
    <canvas id="mainCanvas" width="400" height="400"></canvas>
  </div>
</div>

<div id="colorModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <h2 id="modalTitle">Scegli un colore</h2>
  <input type="color" id="colorPicker" value="#ff0000" />
  <div>
    <button id="cancelBtn">Annulla</button>
    <button id="okBtn">OK</button>
  </div>
</div>

<script>
const GRID_SIZE = 1000;
const CANVAS_SIZE = 400;  // dimensione canvas px
const MINIMAP_SIZE = 400; // stessa dimensione minimap
const SCALE_FACTOR = GRID_SIZE / MINIMAP_SIZE; // 2.5

const BACKEND_URL = 'https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev';

let zoom = parseFloat(localStorage.getItem("zoom")) || 5;
let offsetX = parseFloat(localStorage.getItem("offsetX")) || 0;
let offsetY = parseFloat(localStorage.getItem("offsetY")) || 0;

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const minimap = document.getElementById('minimap');
const miniCtx = minimap.getContext('2d');
miniCtx.imageSmoothingEnabled = false;

const viewportBox = document.getElementById('viewport-box');
const counter = document.getElementById('counter');

let gridData = {};
let selectedSquare = null;

function clampOffsets() {
  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  offsetX = Math.min(Math.max(offsetX, 0), GRID_SIZE - visibleSquares);
  offsetY = Math.min(Math.max(offsetY, 0), GRID_SIZE - visibleSquares);
}

function drawGrid() {
  ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
  const pixelSize = zoom;
  const visibleSquares = Math.floor(CANVAS_SIZE / pixelSize);

  clampOffsets();

  // sfondo griglia
  ctx.fillStyle = '#ddd';
  ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

  // linee griglia
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = 0; x <= visibleSquares; x++) {
    const px = x * pixelSize;
    ctx.moveTo(px, 0);
    ctx.lineTo(px, visibleSquares * pixelSize);
  }
  for (let y = 0; y <= visibleSquares; y++) {
    const py = y * pixelSize;
    ctx.moveTo(0, py);
    ctx.lineTo(visibleSquares * pixelSize, py);
  }
  ctx.stroke();

  // dipingi quadrati
  for (let x = 0; x < visibleSquares; x++) {
    for (let y = 0; y < visibleSquares; y++) {
      const gridX = Math.floor(offsetX) + x;
      const gridY = Math.floor(offsetY) + y;
      const key = `${gridX},${gridY}`;
      if (gridData[key]) {
        ctx.fillStyle = gridData[key].color;
        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
      }
    }
  }

  // evidenzia quadrato selezionato
  if (selectedSquare) {
    const selX = selectedSquare.x - Math.floor(offsetX);
    const selY = selectedSquare.y - Math.floor(offsetY);
    if (selX >= 0 && selX < visibleSquares && selY >= 0 && selY < visibleSquares) {
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 3;
      ctx.strokeRect(selX * pixelSize, selY * pixelSize, pixelSize, pixelSize);
    }
  }
}

function drawMinimap() {
  miniCtx.clearRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
  miniCtx.fillStyle = '#ddd';
  miniCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

  // dipingi quadrati sulla minimap
  for (const key in gridData) {
    const [x, y] = key.split(',').map(Number);
    miniCtx.fillStyle = gridData[key].color;
    miniCtx.fillRect(x / SCALE_FACTOR, y / SCALE_FACTOR, 1 / SCALE_FACTOR, 1 / SCALE_FACTOR);
  }

  // disegna viewport sulla minimap
  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  const scale = MINIMAP_SIZE / GRID_SIZE;
  const boxWidth = visibleSquares * scale;
  const boxHeight = visibleSquares * scale;
  const boxLeft = offsetX * scale;
  const boxTop = offsetY * scale;

  viewportBox.style.width = `${boxWidth}px`;
  viewportBox.style.height = `${boxHeight}px`;
  viewportBox.style.left = `${boxLeft}px`;
  viewportBox.style.top = `${boxTop}px`;
}

function render() {
  drawGrid();
  drawMinimap();
  localStorage.setItem("zoom", zoom);
  localStorage.setItem("offsetX", offsetX);
  localStorage.setItem("offsetY", offsetY);
}

function openColorModal(x, y) {
  selectedSquare = { x, y };
  colorPicker.value = gridData[`${x},${y}`]?.color || '#ff0000';
  colorModal.style.display = 'block';
  colorPicker.focus();
}

function closeColorModal() {
  colorModal.style.display = 'none';
  selectedSquare = null;
}

function paintSquare(x, y, color) {
  fetch(`${BACKEND_URL}/paint`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ x, y, color })
  })
  .then(res => res.json())
  .then(data => {
    if(data.success) {
      gridData[`${x},${y}`] = { color };
      counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
      render();
      closeColorModal();
    } else {
      alert(data.error || 'Errore nella pittura');
      closeColorModal();
    }
  })
  .catch(() => {
    alert('Errore di rete');
    closeColorModal();
  });
}

fetch(`${BACKEND_URL}/painted`)
  .then(res => res.json())
  .then(data => {
    gridData = data;
    counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
    render();
  })
  .catch(() => {
    counter.textContent = "Errore nel caricamento dei dati.";
  });

// Gestione eventi zoom con rotella mouse
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const oldZoom = zoom;
  if (e.deltaY < 0) {
    zoom = Math.min(20, zoom * 1.2);
  } else {
    zoom = Math.max(2, zoom / 1.2);
  }
  // centratura zoom sul mouse
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const beforeX = offsetX + mouseX / oldZoom;
  const beforeY = offsetY + mouseY / oldZoom;
  offsetX = beforeX - mouseX / zoom;
  offsetY = beforeY - mouseY / zoom;

  clampOffsets();
  render();
}, { passive: false });

// Drag per spostare la vista
let isDragging = false;
let dragStartX, dragStartY;
canvas.addEventListener('mousedown', e => {
  isDragging = true;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  canvas.style.cursor = 'grabbing';
});
window.addEventListener('mouseup', () => {
  isDragging = false;
  canvas.style.cursor = 'grab';
});
window.addEventListener('mousemove', e => {
  if (isDragging) {
    const dx = (dragStartX - e.clientX) / zoom;
    const dy = (dragStartY - e.clientY) / zoom;
    offsetX += dx;
    offsetY += dy;
    clampOffsets();
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    render();
  }
});

// Click su quadrato per aprire color picker
canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;
  const gridX = Math.floor(offsetX + clickX / zoom);
  const gridY = Math.floor(offsetY + clickY / zoom);
  openColorModal(gridX, gridY);
});

// Drag sulla minimap per spostare vista
let miniDragging = false;
minimap.addEventListener('mousedown', e => {
  miniDragging = true;
  moveViewportToMini(e);
});
window.addEventListener('mouseup', () => {
  miniDragging = false;
});
minimap.addEventListener('mousemove', e => {
  if (miniDragging) {
    moveViewportToMini(e);
  }
});

function moveViewportToMini(e) {
  const rect = minimap.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;
  x = Math.min(Math.max(0, x), MINIMAP_SIZE);
  y = Math.min(Math.max(0, y), MINIMAP_SIZE);
  const visibleSquares = Math.floor(CANVAS_SIZE / zoom);
  offsetX = x * SCALE_FACTOR - visibleSquares / 2;
  offsetY = y * SCALE_FACTOR - visibleSquares / 2;
  clampOffsets();
  render();
}

// Modal gestione
const colorModal = document.getElementById('colorModal');
const colorPicker = document.getElementById('colorPicker');
const cancelBtn = document.getElementById('cancelBtn');
const okBtn = document.getElementById('okBtn');

cancelBtn.onclick = () => closeColorModal();
colorModal.addEventListener('keydown', e => {
  if(e.key === 'Escape') closeColorModal();
});
okBtn.onclick = () => {
  if(!selectedSquare) return closeColorModal();
  paintSquare(selectedSquare.x, selectedSquare.y, colorPicker.value);
};

// Primo render e setup
canvas.style.cursor = 'grab';
render();
</script>
</body>
</html>
