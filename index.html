<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Invisible Million</title>
<style>
  * { box-sizing: border-box; }
  body, html {
    margin: 0; padding: 0; height: 100vh; overflow: hidden;
    font-family: Arial, sans-serif;
    background: #000;
    color: #eee;
  }
  a {
    color: #4eaaff;
    text-decoration: none;
  }
  a:hover {
    text-decoration: underline;
  }
  #container {
    display: flex;
    height: 100vh;
    width: 100vw;
  }
  #sidebar {
    width: 250px;
    background: #111;
    border-right: 1px solid #444;
    display: flex;
    flex-direction: column;
    padding: 10px;
  }
  #sidebar h2 { margin: 0 0 10px 0; font-weight: normal; font-size: 20px; }
  #links { margin-bottom: 15px; }
  #links a { display: block; margin-bottom: 8px; font-weight: bold; }
  #minimap-container {
    flex-grow: 1;
    background: #000;
    border: 1px solid #444;
    position: relative;
  }
  #main {
    flex-grow: 1;
    background: #000;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  #topbar {
    background: #111;
    padding: 8px 12px;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    border-bottom: 1px solid #444;
  }
  button {
    background: #4eaaff;
    border: none;
    color: white;
    padding: 6px 14px;
    font-size: 14px;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover { background: #357ab7; }
  #grid-container {
    flex-grow: 1;
    overflow: hidden;
    position: relative;
    touch-action: none;
    background: #000;
  }
  #grid-canvas {
    position: absolute;
    top: 0; left: 0;
    user-select: none;
    background: #000;
  }
  /* Minimap canvas */
  #minimap-canvas {
    width: 100%;
    height: 100%;
    display: block;
    image-rendering: pixelated;
  }
  /* Color picker popup */
  #colorPickerPopup {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #222;
    padding: 20px;
    border: 2px solid #4eaaff;
    border-radius: 8px;
    display: none;
    z-index: 9999;
  }
  #colorPickerPopup input[type=color] {
    width: 100px;
    height: 40px;
    border: none;
    cursor: pointer;
    margin-right: 10px;
    vertical-align: middle;
  }
  #colorPickerPopup button {
    padding: 6px 12px;
    font-size: 14px;
  }
  #errorPopup {
    position: fixed;
    top: 10%;
    left: 50%;
    transform: translateX(-50%);
    background: #b22;
    color: white;
    padding: 10px 20px;
    border-radius: 6px;
    display: none;
    z-index: 10000;
  }
</style>
</head>
<body>

<div id="container">

  <div id="sidebar">
    <h2>Menu</h2>
    <div id="links">
      <a href="page1.html" target="_blank">Static Page 1</a>
      <a href="page2.html" target="_blank">Static Page 2</a>
      <a href="page3.html" target="_blank">Static Page 3</a>
    </div>
    <div id="minimap-container">
      <canvas id="minimap-canvas" width="250" height="250"></canvas>
    </div>
  </div>

  <div id="main">
    <div id="topbar">
      <button id="donateBtn">Donate</button>
      <button id="fullscreenBtn">Fullscreen</button>
    </div>
    <div id="grid-container">
      <canvas id="grid-canvas"></canvas>
    </div>
  </div>

</div>

<!-- Color picker popup -->
<div id="colorPickerPopup">
  <input type="color" id="colorPicker" value="#ff0000" />
  <button id="okColorBtn">OK</button>
  <button id="cancelColorBtn">Cancel</button>
</div>

<!-- Error popup -->
<div id="errorPopup"></div>

<script>
(() => {
  // Constants
  const GRID_SIZE = 1000;
  const SQUARE_SIZE = 10;
  const MAX_ZOOM = 5;
  const MIN_ZOOM = 0.1;
  const MINIMAP_SIZE = 250;

  // Backend URLs (adjust if needed)
  const API_BASE = 'http://localhost:3000';
  const WS_URL = 'ws://localhost:8765';

  // DOM Elements
  const canvas = document.getElementById('grid-canvas');
  const ctx = canvas.getContext('2d');
  const gridContainer = document.getElementById('grid-container');
  const minimapCanvas = document.getElementById('minimap-canvas');
  const minimapCtx = minimapCanvas.getContext('2d');
  const donateBtn = document.getElementById('donateBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const colorPickerPopup = document.getElementById('colorPickerPopup');
  const colorPicker = document.getElementById('colorPicker');
  const okColorBtn = document.getElementById('okColorBtn');
  const cancelColorBtn = document.getElementById('cancelColorBtn');
  const errorPopup = document.getElementById('errorPopup');

  // State variables
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;
  let isDragging = false;
  let dragStart = null;

  let hasDonated = false;
  let selectedSquare = null; // {x, y}

  // Store colored squares: key = "x,y" -> color string
  let coloredSquares = {};

  // WebSocket connection
  let ws;

  // Setup canvas size
  function resizeCanvas() {
    const rect = gridContainer.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    draw();
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Draw main grid with current state
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Calculate visible area in grid coords
    const viewLeft = -offsetX / zoom;
    const viewTop = -offsetY / zoom;
    const viewWidth = canvas.width / zoom;
    const viewHeight = canvas.height / zoom;

    // Draw colored squares visible in viewport
    for (const key in coloredSquares) {
      const [cx, cy] = key.split(',').map(Number);
      if (
        cx * SQUARE_SIZE + SQUARE_SIZE < viewLeft ||
        cx * SQUARE_SIZE > viewLeft + viewWidth ||
        cy * SQUARE_SIZE + SQUARE_SIZE < viewTop ||
        cy * SQUARE_SIZE > viewTop + viewHeight
      ) {
        continue; // Not visible
      }
      const px = offsetX + cx * SQUARE_SIZE * zoom;
      const py = offsetY + cy * SQUARE_SIZE * zoom;
      const size = SQUARE_SIZE * zoom;
      ctx.fillStyle = coloredSquares[key];
      ctx.fillRect(px, py, size, size);
    }

    // Draw dark grey (#333) squares backgrounds for uncolored squares visible
    ctx.fillStyle = '#333';
    const startX = Math.max(0, Math.floor(viewLeft / SQUARE_SIZE));
        const startX = Math.max(0, Math.floor(viewLeft / SQUARE_SIZE));
    const startY = Math.max(0, Math.floor(viewTop / SQUARE_SIZE));
    const endX = Math.min(GRID_SIZE - 1, Math.ceil((viewLeft + viewWidth) / SQUARE_SIZE));
    const endY = Math.min(GRID_SIZE - 1, Math.ceil((viewTop + viewHeight) / SQUARE_SIZE));

    for (let x = startX; x <= endX; x++) {
      for (let y = startY; y <= endY; y++) {
        const key = `${x},${y}`;
        if (!coloredSquares[key]) {
          const px = offsetX + x * SQUARE_SIZE * zoom;
          const py = offsetY + y * SQUARE_SIZE * zoom;
          ctx.fillRect(px, py, SQUARE_SIZE * zoom, SQUARE_SIZE * zoom);
        }
      }
    }

    // Draw grid lines (light gray #ccc)
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    for (let x = startX; x <= endX; x++) {
      const px = offsetX + x * SQUARE_SIZE * zoom;
      ctx.beginPath();
      ctx.moveTo(px, offsetY + startY * SQUARE_SIZE * zoom);
      ctx.lineTo(px, offsetY + (endY + 1) * SQUARE_SIZE * zoom);
      ctx.stroke();
    }
    for (let y = startY; y <= endY; y++) {
      const py = offsetY + y * SQUARE_SIZE * zoom;
      ctx.beginPath();
      ctx.moveTo(offsetX + startX * SQUARE_SIZE * zoom, py);
      ctx.lineTo(offsetX + (endX + 1) * SQUARE_SIZE * zoom, py);
      ctx.stroke();
    }

    // Draw selection highlight if any
    if (selectedSquare) {
      const px = offsetX + selectedSquare.x * SQUARE_SIZE * zoom;
      const py = offsetY + selectedSquare.y * SQUARE_SIZE * zoom;
      ctx.strokeStyle = '#4eaaff';
      ctx.lineWidth = 3;
      ctx.strokeRect(px + 1, py + 1, SQUARE_SIZE * zoom - 2, SQUARE_SIZE * zoom - 2);
    }

    drawMinimap();
  }

  // Draw minimap (250x250)
  function drawMinimap() {
    minimapCtx.clearRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
    // Black background
    minimapCtx.fillStyle = '#000';
    minimapCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

    // Draw colored squares scaled down (each pixel = 4 squares)
    const scale = MINIMAP_SIZE / GRID_SIZE;

    for (const key in coloredSquares) {
      const [x, y] = key.split(',').map(Number);
      minimapCtx.fillStyle = coloredSquares[key];
      minimapCtx.fillRect(x * scale, y * scale, scale, scale);
    }

    // Draw viewport rectangle on minimap
    const viewLeft = -offsetX / zoom;
    const viewTop = -offsetY / zoom;
    const viewWidth = canvas.width / zoom;
    const viewHeight = canvas.height / zoom;

    minimapCtx.strokeStyle = '#4eaaff';
    minimapCtx.lineWidth = 2;
    minimapCtx.strokeRect(viewLeft * scale, viewTop * scale, viewWidth * scale, viewHeight * scale);
  }

  // Convert page/client coords to grid coords (square x,y)
  function clientToGrid(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const px = (clientX - rect.left - offsetX) / zoom;
    const py = (clientY - rect.top - offsetY) / zoom;
    const x = Math.floor(px / SQUARE_SIZE);
    const y = Math.floor(py / SQUARE_SIZE);
    if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return null;
    return { x, y };
  }

  // Show error popup with message for 3 seconds
  function showError(msg) {
    errorPopup.textContent = msg;
    errorPopup.style.display = 'block';
    setTimeout(() => {
      errorPopup.style.display = 'none';
    }, 3000);
  }

  // Handle clicking on grid canvas
  canvas.addEventListener('click', (e) => {
    if (!hasDonated) return;
    if (selectedSquare !== null) return; // Only one square at a time
    const gridPos = clientToGrid(e.clientX, e.clientY);
    if (!gridPos) return;

    const key = `${gridPos.x},${gridPos.y}`;
    if (coloredSquares[key]) {
      showError("Oops! This square is already taken. Try another one.");
      return;
    }
    selectedSquare = gridPos;
    colorPicker.value = '#ff0000'; // reset color picker to red
    colorPickerPopup.style.display = 'block';
  });

  // Handle OK button on color picker
  okColorBtn.addEventListener('click', async () => {
    if (!selectedSquare) return;

    const key = `${selectedSquare.x},${selectedSquare.y}`;
    const color = colorPicker.value;

    try {
      const res = await fetch(`${API_BASE}/paint`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          x: selectedSquare.x,
          y: selectedSquare.y,
          color,
        }),
      });
      const data = await res.json();

      if (!res.ok) {
        showError(data.error || 'Error painting the square.');
        selectedSquare = null;
        colorPickerPopup.style.display = 'none';
        draw();
        return;
      }

      // Success: update local grid and redraw
      coloredSquares[key] = color;
      selectedSquare = null;
      colorPickerPopup.style.display = 'none';
      draw();
    } catch (err) {
      showError('Network error. Please try again.');
      selectedSquare = null;
      colorPickerPopup.style.display = 'none';
      draw();
    }
  });

  cancelColorBtn.addEventListener('click', () => {
    selectedSquare = null;
    colorPickerPopup.style.display = 'none';
    draw();
  });

  // Donate button simulates donation and enables coloring
  donateBtn.addEventListener('click', () => {
    hasDonated = true;
    donateBtn.disabled = true;
    donateBtn.textContent = "Thank you!";
  });

  // Fullscreen button
  fullscreenBtn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });

  // Zoom & pan handlers

  // Handle mouse wheel zoom
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomAmount = -e.deltaY * 0.001;
    let newZoom = zoom * (1 + zoomAmount);
    newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newZoom));

    // Zoom on mouse pointer
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Adjust offset so zoom is centered on pointer
    offsetX -= (mx / zoom - mx / newZoom);
    offsetY -= (my / zoom - my / newZoom);
    zoom = newZoom;
    draw();
  }, { passive: false });

  // Drag to pan
  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart = {x: e.clientX, y: e.clientY};
  });
  window.addEventListener('mouseup', (e) => {
    isDragging = false;
    dragStart = null;
  });
  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    offsetX += dx;
    offsetY += dy;
    dragStart = {x: e.clientX, y: e.clientY};
    draw();
  });

  // Touch support for pan and pinch zoom
  let lastTouchDist = null;
  let lastTouchCenter = null;
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      dragStart = {x: e.touches[0].clientX, y: e.touches[0].clientY};
    } else if (e.touches.length === 2) {
      isDragging = false;
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      lastTouchDist = Math.hypot(dx, dy);
      lastTouchCenter = {
        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
        y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
      };
    }
  }, {passive: false});
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length === 1 && isDragging) {
      const dx = e.touches[0].clientX - dragStart.x;
      const dy = e.touches[0].clientY - dragStart.y;
      offsetX += dx;
      offsetY += dy;
      dragStart = {x: e.touches[0].clientX, y: e.touches[0].clientY};
      draw();
    } else if (e.touches.length === 2 && lastTouchDist !== null) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const newDist = Math.hypot(dx, dy);
      let newZoom = zoom * (newDist / lastTouchDist);
      newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newZoom));

      // Zoom centered on touch midpoint
      const rect = canvas.getBoundingClientRect();
      const mx = lastTouchCenter.x - rect.left;
      const my = lastTouchCenter.y - rect.top;

      offsetX -= (mx / zoom - mx / newZoom);
      offsetY -= (my / zoom - my / newZoom);

      zoom = newZoom;
      lastTouchDist = newDist;
      lastTouchCenter = {
        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
        y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
      };
      draw();
    }
  }, {passive: false});
  canvas.addEventListener('touchend', (e) => {
    if (e.touches.length < 2) {
      lastTouchDist = null;
      lastTouchCenter = null;
    }
    if (e.touches.length === 0) {
      isDragging = false;
      dragStart = null;
    }
  });

  // Connect WebSocket and sync state
  function setupWebSocket() {
    ws = new WebSocket(WS_URL);

    ws.onopen = () => {
      console.log('WebSocket connected');
      ws.send(JSON.stringify({type: 'request_state'}));
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === 'state') {
          // Replace all squares
          coloredSquares = data.coloredSquares || {};
          draw();
        } else if (data.type === 'color_update') {
          const key = `${data.x},${data.y}`;
          coloredSquares[key] = data.color;
          draw();
        }
      } catch (e) {
        console.error('WS message parse error:', e);
      }
    };

    ws.onclose = () => {
      console.log('WebSocket disconnected, retry in 3s...');
      setTimeout(setupWebSocket, 3000);
    };

    ws.onerror = (e) => {
      console.error('WebSocket error', e);
      ws.close();
    };
  }

  // Initial draw and WS setup
  draw();
  setupWebSocket();

  // Minimap click to move viewport
  minimapCanvas.addEventListener('click', (e) => {
    const rect = minimapCanvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    const scale = MINIMAP_SIZE / GRID_SIZE;

    // Center viewport around click on minimap
    const centerGridX = clickX / scale;
    const centerGridY = clickY / scale;

    const viewWidth = canvas.width / zoom;
    const viewHeight = canvas.height / zoom;

    offsetX = -centerGridX * SQUARE_SIZE * zoom + canvas.width / 2;
    offsetY = -centerGridY * SQUARE_SIZE * zoom + canvas.height / 2;

    draw();
  });
})();

