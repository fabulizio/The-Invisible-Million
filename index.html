        offsetX -= (midX - offsetX) * (zoom / oldZoom - 1);
        offsetY -= (midY - offsetY) * (zoom / oldZoom - 1);
        clampOffset();
        saveView();
      }
      lastTouchDist = dist;
    }
  }, {passive:false});
  mainCanvas.addEventListener('touchend', e => {
    if(e.touches.length < 2) {
      lastTouchDist = null;
    }
  });

  function getTouchDistance(t1, t2) {
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  // Double tap / double click fullscreen toggle
  let lastTap = 0;
  mainCanvas.addEventListener('touchend', e => {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    if(tapLength < 300 && tapLength > 0) {
      toggleFullscreen();
      e.preventDefault();
    }
    lastTap = currentTime;
  });

  mainCanvas.addEventListener('dblclick', e => {
    toggleFullscreen();
  });

  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        alert(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      document.exitFullscreen();
    }
  }

  // Minimap interaction: drag viewport rect
  minimapCanvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    const rect = minimapCanvas.getBoundingClientRect();
    const scaleX = minimapCanvas.width / (GRID_SIZE * CELL_SIZE);
    const scaleY = minimapCanvas.height / (GRID_SIZE * CELL_SIZE);
    const scale = Math.min(scaleX, scaleY);

    // Calculate viewport rectangle
    const viewX = -offsetX * scale / zoom;
    const viewY = -offsetY * scale / zoom;
    const viewW = minimapCanvas.width / zoom;
    const viewH = minimapCanvas.height / zoom;

    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (mx >= viewX && mx <= viewX + viewW && my >= viewY && my <= viewY + viewH) {
      dragCell = {startX: mx, startY: my, offsetX, offsetY};
      minimapCanvas.setPointerCapture(e.pointerId);
    }
  });
  minimapCanvas.addEventListener('pointermove', e => {
    if (!dragCell) return;
    e.preventDefault();
    const rect = minimapCanvas.getBoundingClientRect();
    const scaleX = minimapCanvas.width / (GRID_SIZE * CELL_SIZE);
    const scaleY = minimapCanvas.height / (GRID_SIZE * CELL_SIZE);
    const scale = Math.min(scaleX, scaleY);

    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const dx = mx - dragCell.startX;
    const dy = my - dragCell.startY;

    // Translate dx, dy in pixels on main canvas
    const panDx = -dx * zoom / scale;
    const panDy = -dy * zoom / scale;

    offsetX = dragCell.offsetX + panDx;
    offsetY = dragCell.offsetY + panDy;
    clampOffset();
    saveView();
  });
  minimapCanvas.addEventListener('pointerup', e => {
    dragCell = null;
    minimapCanvas.releasePointerCapture(e.pointerId);
  });
  minimapCanvas.addEventListener('pointercancel', e => {
    dragCell = null;
    minimapCanvas.releasePointerCapture(e.pointerId);
  });

  // Responsive resize
  window.addEventListener('resize', () => {
    resizeCanvases();
    clampOffset();
  });

  // Initial setup
  function init() {
    resizeCanvases();
    loadCells();
    loadView();
    clampOffset();
    animate();
  }
  init();

})();
</script>
</body>
</html>
