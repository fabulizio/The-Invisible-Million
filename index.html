<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Invisible Million</title>
<style>
  /* Reset & basics */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0; height: 100vh; overflow: hidden; 
    font-family: Arial, sans-serif;
    background: #000;
    color: #eee;
  }
  a {
    color: #4eaaff;
    text-decoration: none;
  }
  a:hover {
    text-decoration: underline;
  }

  /* Layout */
  #container {
    display: flex;
    height: 100vh;
    width: 100vw;
  }
  #sidebar {
    width: 250px;
    background: #111;
    border-right: 1px solid #444;
    display: flex;
    flex-direction: column;
    padding: 10px;
  }
  #sidebar h2 {
    margin: 0 0 10px 0;
    font-weight: normal;
    font-size: 20px;
  }
  #links {
    margin-bottom: 15px;
  }
  #links a {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
  }

  /* Minimap container inside sidebar */
  #minimap-container {
    flex-grow: 1;
    background: #000;
    border: 1px solid #444;
    position: relative;
  }

  /* Main area */
  #main {
    flex-grow: 1;
    background: #000;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* Top bar with donation + fullscreen */
  #topbar {
    background: #111;
    padding: 8px 12px;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    border-bottom: 1px solid #444;
  }
  button {
    background: #4eaaff;
    border: none;
    color: white;
    padding: 6px 14px;
    font-size: 14px;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover {
    background: #357ab7;
  }

  /* Grid container with zoom & pan */
  #grid-container {
    flex-grow: 1;
    overflow: hidden;
    position: relative;
    touch-action: none;
    background: #000;
  }
  #grid-canvas {
    position: absolute;
    top: 0; left: 0;
    user-select: none;
    background: #000;
  }
</style>
</head>
<body>

<div id="container">

  <div id="sidebar">
    <h2>Menu</h2>
    <div id="links">
      <a href="page1.html" target="_blank">Static Page 1</a>
      <a href="page2.html" target="_blank">Static Page 2</a>
      <a href="page3.html" target="_blank">Static Page 3</a>
    </div>
    <div id="minimap-container"></div>
  </div>

  <div id="main">
    <div id="topbar">
      <button id="donateBtn">Donate</button>
      <button id="fullscreenBtn">Fullscreen</button>
    </div>
    <div id="grid-container">
      <canvas id="grid-canvas"></canvas>
    </div>
  </div>

</div>

<script>
(() => {
  const GRID_SIZE = 1000;  // 1000x1000 squares
  const SQUARE_SIZE = 10;  // each square nominal size in pixels (at zoom = 1)

  // DOM elements
  const canvas = document.getElementById('grid-canvas');
  const ctx = canvas.getContext('2d');
  const gridContainer = document.getElementById('grid-container');
  const minimapContainer = document.getElementById('minimap-container');
  const donateBtn = document.getElementById('donateBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');

  // State
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;
  let isDragging = false;
  let dragStart = null;

  // Minimap constants
  const minimapScale = 0.05; // 5% scale
  const minimapWidth = GRID_SIZE * minimapScale;
  const minimapHeight = GRID_SIZE * minimapScale;

  // Viewport rect in minimap coords
  const viewportRect = { x: 0, y: 0, width: 0, height: 0 };

  // Setup canvas size
  function resizeCanvas() {
    const rect = gridContainer.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    draw();
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Draw visible portion of grid
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Fill background black
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Calculate visible area in grid coords
    const viewLeft = -offsetX / zoom;
    const viewTop = -offsetY / zoom;
    const viewWidth = canvas.width / zoom;
    const viewHeight = canvas.height / zoom;

    // Calculate start/end squares to draw (clamp inside grid)
    const startX = Math.max(0, Math.floor(viewLeft / SQUARE_SIZE));
    const startY = Math.max(0, Math.floor(viewTop / SQUARE_SIZE));
    const endX = Math.min(GRID_SIZE - 1, Math.ceil((viewLeft + viewWidth) / SQUARE_SIZE));
    const endY = Math.min(GRID_SIZE - 1, Math.ceil((viewTop + viewHeight) / SQUARE_SIZE));

    // Draw squares: dark grey fill (#333)
    ctx.fillStyle = '#333';

    for (let y = startY; y <= endY; y++) {
      for (let x = startX; x <= endX; x++) {
        const px = offsetX + x * SQUARE_SIZE * zoom;
        const py = offsetY + y * SQUARE_SIZE * zoom;
        const size = SQUARE_SIZE * zoom;
        ctx.fillRect(px, py, size, size);
      }
    }

    // Draw grid lines: light grey (#ccc)
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;

    // Vertical lines
    for (let x = startX; x <= endX + 1; x++) {
      const px = offsetX + x * SQUARE_SIZE * zoom;
      ctx.beginPath();
      ctx.moveTo(px, offsetY + startY * SQUARE_SIZE * zoom);
      ctx.lineTo(px, offsetY + (endY + 1) * SQUARE_SIZE * zoom);
      ctx.stroke();
    }

    // Horizontal lines
    for (let y = startY; y <= endY + 1; y++) {
      const py = offsetY + y * SQUARE_SIZE * zoom;
      ctx.beginPath();
      ctx.moveTo(offsetX + startX * SQUARE_SIZE * zoom, py);
      ctx.lineTo(offsetX + (endX + 1) * SQUARE_SIZE * zoom, py);
      ctx.stroke();
    }

    updateMinimapViewport();
  }

  // Pan handling
  gridContainer.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart = { x: e.clientX, y: e.clientY, offsetX, offsetY };
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
    dragStart = null;
  });
  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    offsetX = dragStart.offsetX + dx;
    offsetY = dragStart.offsetY + dy;
    draw();
  });

  // Zoom on wheel
  gridContainer.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = gridContainer.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wheel = e.deltaY < 0 ? 1.1 : 0.9;
    const newZoom = Math.min(5, Math.max(0.1, zoom * wheel));
    // Zoom towards mouse pointer
    offsetX -= (mouseX / zoom) * (newZoom - zoom);
    offsetY -= (mouseY / zoom) * (newZoom - zoom);
    zoom = newZoom;
    draw();
  }, { passive: false });

  // Pinch zoom
  let pinchStartDist = 0;
  let pinchStartZoom = 1;
  gridContainer.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      pinchStartDist = getDistance(e.touches[0], e.touches[1]);
      pinchStartZoom = zoom;
    }
  });
  gridContainer.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const newDist = getDistance(e.touches[0], e.touches[1]);
      let newZoom = pinchStartZoom * (newDist / pinchStartDist);
      newZoom = Math.min(5, Math.max(0.1, newZoom));
      zoom = newZoom;
      draw();
    }
  }, { passive: false });

  function getDistance(t1, t2) {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Double tap fullscreen toggle
  let lastTap = 0;
  gridContainer.addEventListener('touchend', () => {
    const now = Date.now();
    if (now - lastTap < 300) toggleFullscreen();
    lastTap = now;
  });

  fullscreenBtn.addEventListener('click', toggleFullscreen);

  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }

  // --- Minimap setup ---

  const minimapCanvas = document.createElement('canvas');
  minimapCanvas.width = minimapWidth;
  minimapCanvas.height = minimapHeight;
  minimapCanvas.style.width = '100%';
  minimapCanvas.style.height = 'auto';
  minimapCanvas.style.display = 'block';
  minimapContainer.appendChild(minimapCanvas);
  const mmCtx = minimapCanvas.getContext('2d');

  function drawMinimap() {
    // Black background
    mmCtx.fillStyle = '#000';
    mmCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

    // Draw all squares as dark grey (#333)
    mmCtx.fillStyle = '#333';
    mmCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

    // Draw grid lines light grey (#ccc) every 10 squares (to reduce clutter)
    mmCtx.strokeStyle = '#555';
    mmCtx.lineWidth = 0.5;
    const step = 10 * minimapScale * SQUARE_SIZE;

    for (let x = 0; x <= minimapCanvas.width; x += step) {
      mmCtx.beginPath();
      mmCtx.moveTo(x, 0);
      mmCtx.lineTo(x, minimapCanvas.height);
      mmCtx.stroke();
    }
    for (let y = 0; y <= minimapCanvas.height; y += step) {
      mmCtx.beginPath();
      mmCtx.moveTo(0, y);
      mmCtx.lineTo(minimapCanvas.width, y);
      mmCtx.stroke();
    }
  }

  function updateMinimapViewport() {
    // Clear minimap first
    drawMinimap();

    // Calculate viewport rect on minimap scale
    const viewLeft = -offsetX / zoom;
    const viewTop = -offsetY / zoom;
    const viewWidth = canvas.width / zoom;
    const viewHeight = canvas.height / zoom;

    viewportRect.x = viewLeft * minimapScale;
    viewportRect.y = viewTop * minimapScale;
    viewportRect.width = viewWidth * minimapScale;
    viewportRect.height = viewHeight * minimapScale;

    // Draw red viewport rectangle
    mmCtx.strokeStyle = 'red';
    mmCtx.lineWidth = 2;
    mmCtx.strokeRect(viewportRect.x, viewportRect.y, viewportRect.width, viewportRect.height);
  }

  // Clicking on minimap to pan grid view
  minimapCanvas.addEventListener('click', (e) => {
    const rect = minimapCanvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Center view on clicked point
    const centerGridX = clickX / minimapScale;
    const centerGridY = clickY / minimapScale;

    offsetX = canvas.width / 2 - centerGridX * zoom;
    offsetY = canvas.height / 2 - centerGridY * zoom;
    draw();
  });

  // Donation button handler (placeholder)
  donateBtn.addEventListener('click', () => {
    alert('Donation functionality coming soon!');
  });

  // Initial draws
  draw();
  drawMinimap();
})();
</script>

</body>
</html>
