<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zoomable Grid with Backend</title>
<style>
  * { box-sizing: border-box; }
  body, html {
    margin: 0; padding: 0; height: 100%;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
  }
  header {
    position: sticky;
    top: 0;
    background: #222;
    color: white;
    padding: 10px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    z-index: 10;
  }
  header .left-links a {
    color: #aaf;
    margin-right: 15px;
    text-decoration: none;
    font-weight: 600;
  }
  header .left-links a:hover { text-decoration: underline; }
  header button {
    background: #4CAF50;
    border: none;
    color: white;
    padding: 8px 15px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
  }
  header button:focus, header button:hover { background: #45a049; outline: 2px solid #fff; }

  footer {
    position: sticky;
    bottom: 0;
    background: #222;
    color: white;
    padding: 10px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    z-index: 10;
    flex-wrap: wrap;
    gap: 10px;
  }
  footer .coords { font-family: monospace; }
  footer label { margin-right: 10px; }
  footer select {
    padding: 4px 8px;
    border-radius: 3px;
    border: none;
    font-size: 1em;
  }
  footer .zoom-controls button {
    background: #555; color: #fff; border: none; border-radius: 3px;
    margin: 0 2px; padding: 5px 10px; font-size: 1em; cursor: pointer;
  }
  footer .zoom-controls button:focus, footer .zoom-controls button:hover {
    background: #888; outline: 2px solid #fff;
  }
  main {
    flex: 1 1 auto;
    background: #f0f0f0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 15px;
    overflow: hidden;
  }
  #frame {
    position: relative;
    width: 90vw;
    max-width: 1000px;
    height: 70vh;
    max-height: 800px;
    outline: 3px solid #333;
    background: white;
    overflow: hidden;
    touch-action: none;
  }
  #gridCanvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: block;
    cursor: grab;
    user-select: none;
  }
  #gridCanvas:active { cursor: grabbing; }
</style>
</head>
<body>

<header role="banner">
  <div class="left-links">
    <a href="#stati1" tabindex="1">Stati Page 1</a>
    <a href="#stati2" tabindex="2">Stati Page 2</a>
  </div>
  <button id="donateBtn" tabindex="3" aria-label="Donate">Donate</button>
</header>

<main>
  <div id="frame" tabindex="0" aria-label="Zoomable grid frame">
    <canvas id="gridCanvas" aria-label="Grid canvas" tabindex="4"></canvas>
  </div>
</main>

<footer role="contentinfo">
  <div class="coords" aria-live="polite" aria-atomic="true">X: 0, Y: 0</div>
  <div>
    <label for="colorSelect">Select Color:</label>
    <select id="colorSelect" aria-label="Select drawing color" tabindex="5">
      <option value="#000000" selected>Black</option>
      <option value="#FF0000">Red</option>
      <option value="#00AA00">Green</option>
      <option value="#0000FF">Blue</option>
      <option value="#FFA500">Orange</option>
      <option value="#800080">Purple</option>
    </select>
  </div>
  <div class="zoom-controls" aria-label="Zoom controls">
    <button id="zoomOutBtn" title="Zoom out" tabindex="6">âˆ’</button>
    <span id="zoomDisplay" aria-live="polite">100%</span>
    <button id="zoomInBtn" title="Zoom in" tabindex="7">+</button>
  </div>
</footer>

<script>
(() => {
  const BACKEND_URL = "https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev";

  // DOM elements
  const canvas = document.getElementById('gridCanvas');
  const ctx = canvas.getContext('2d');
  const frame = document.getElementById('frame');
  const coordsDisplay = document.querySelector('footer .coords');
  const colorSelect = document.getElementById('colorSelect');
  const donateBtn = document.getElementById('donateBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const zoomDisplay = document.getElementById('zoomDisplay');

  // Grid settings
  const GRID_SIZE = 1100;
  const CELL_SIZE = 30;
  const MIN_ZOOM = 0.5;
  const MAX_ZOOM = 3;
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;

  // State
  let isDragging = false;
  let dragStart = {x: 0, y: 0};
  let offsetStart = {x: 0, y: 0};
  let currentCell = {x: 0, y: 0};
  let selectedColor = colorSelect.value;
  let coloredCells = {}; // { "x,y": color }

  // Redraw throttling
  let redrawPending = false;

  // Touch support
  let touchStart = null;

  function setCanvasSize() {
    const rect = frame.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    clampOffset();
    drawGrid();
  }

  function drawGrid() {
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, width, height);

    const scaledCellSize = CELL_SIZE * zoom;
    const startCol = Math.floor(-offsetX / scaledCellSize);
    const startRow = Math.floor(-offsetY / scaledCellSize);
    const visibleCols = Math.ceil(width / scaledCellSize) + 1;
    const visibleRows = Math.ceil(height / scaledCellSize) + 1;

    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;

    for(let c = startCol; c <= startCol + visibleCols; c++) {
      if (c < 0 || c >= GRID_SIZE) continue;
      const x = offsetX + c * scaledCellSize;
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, height);
      ctx.stroke();
    }
    for(let r = startRow; r <= startRow + visibleRows; r++) {
      if (r < 0 || r >= GRID_SIZE) continue;
      const y = offsetY + r * scaledCellSize;
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(width, y + 0.5);
      ctx.stroke();
    }

    // Draw colored cells from backend
    for (const key in coloredCells) {
      const [x, y] = key.split(',').map(Number);
      if (
        x >= startCol && x <= startCol + visibleCols &&
        y >= startRow && y <= startRow + visibleRows
      ) {
        const cellX = offsetX + x * scaledCellSize;
        const cellY = offsetY + y * scaledCellSize;
        ctx.fillStyle = coloredCells[key];
        ctx.fillRect(cellX + 1, cellY + 1, scaledCellSize - 2, scaledCellSize - 2);
      }
    }

    // Highlight hovered cell
    if(currentCell.x >= 0 && currentCell.x < GRID_SIZE &&
      currentCell.y >= 0 && currentCell.y < GRID_SIZE) {
      const highlightX = offsetX + currentCell.x * scaledCellSize;
      const highlightY = offsetY + currentCell.y * scaledCellSize;
      ctx.fillStyle = selectedColor + '88';
      ctx.fillRect(highlightX + 1, highlightY + 1, scaledCellSize - 2, scaledCellSize - 2);
    }
  }

  function requestRedraw() {
    if (redrawPending) return;
    redrawPending = true;
    requestAnimationFrame(() => {
      drawGrid();
      redrawPending = false;
    });
  }

  function updateCoordsDisplay(cellX, cellY) {
    coordsDisplay.textContent = `X: ${cellX}, Y: ${cellY}`;
  }

  function pixelToCell(x, y) {
    const scaledCellSize = CELL_SIZE * zoom;
    const cellX = Math.floor((x - offsetX) / scaledCellSize);
    const cellY = Math.floor((y - offsetY) / scaledCellSize);
    return {x: cellX, y: cellY};
  }

  function clampOffset() {
    const scaledCellSize = CELL_SIZE * zoom;
    const maxOffsetX = 0;
    const maxOffsetY = 0;
    const minOffsetX = Math.min(canvas.width - GRID_SIZE * scaledCellSize, 0);
    const minOffsetY = Math.min(canvas.height - GRID_SIZE * scaledCellSize, 0);

    if (minOffsetX > maxOffsetX) {
      offsetX = (canvas.width - GRID_SIZE * scaledCellSize) / 2;
    } else {
      offsetX = Math.min(maxOffsetX, Math.max(minOffsetX, offsetX));
    }
    if (minOffsetY > maxOffsetY) {
      offsetY = (canvas.height - GRID_SIZE * scaledCellSize) / 2;
    } else {
      offsetY = Math.min(maxOffsetY, Math.max(minOffsetY, offsetY));
    }
  }

  // Ensures the hovered cell is always fully visible in the frame
  function ensureCellVisible(cellX, cellY) {
    const scaledCellSize = CELL_SIZE * zoom;
    const cellLeft = offsetX + cellX * scaledCellSize;
    const cellRight = cellLeft + scaledCellSize;
    const cellTop = offsetY + cellY * scaledCellSize;
    const cellBottom = cellTop + scaledCellSize;

    let changed = false;

    if (cellLeft < 0) {
      offsetX += -cellLeft;
      changed = true;
    }
    if (cellRight > canvas.width) {
      offsetX -= cellRight - canvas.width;
      changed = true;
    }
    if (cellTop < 0) {
      offsetY += -cellTop;
      changed = true;
    }
    if (cellBottom > canvas.height) {
      offsetY -= cellBottom - canvas.height;
      changed = true;
    }
    if (changed) {
      clampOffset();
      requestRedraw();
    }
  }

  function setZoom(newZoom, centerX, centerY) {
    const oldZoom = zoom;
    zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newZoom));
    if (centerX === undefined || centerY === undefined) {
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
    }
    offsetX = centerX - ((centerX - offsetX) * (zoom / oldZoom));
    offsetY = centerY - ((centerY - offsetY) * (zoom / oldZoom));
    clampOffset();
    zoomDisplay.textContent = Math.round(zoom * 100) + '%';
    requestRedraw();
  }

  // Backend communication
  function sendCellColor(x, y, color) {
    fetch(`${BACKEND_URL}/cell`, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({x, y, color})
    })
    .then(res => res.json())
    .then(data => {
      // Optionally handle response
    })
    .catch(err => {
      console.error('Backend error:', err);
    });
  }

  function fetchGridState() {
    fetch(`${BACKEND_URL}/grid`)
      .then(res => res.json())
      .then(data => {
        if (data && data.cells) {
          coloredCells = {};
          data.cells.forEach(cell => {
            coloredCells[`${cell.x},${cell.y}`] = cell.color;
          });
          requestRedraw();
        }
      })
      .catch(err => {
        console.error('Failed to fetch grid state:', err);
      });
  }

  // Wheel zoom
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomStep = 1.1;
    if(e.deltaY < 0) setZoom(zoom * zoomStep, e.offsetX, e.offsetY);
    else setZoom(zoom / zoomStep, e.offsetX, e.offsetY);
  }, {passive: false});

  // Mouse drag pan
  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart.x = e.clientX;
    dragStart.y = e.clientY;
    offsetStart.x = offsetX;
    offsetStart.y = offsetY;
    canvas.setPointerCapture(e.pointerId || 0);
  });
  window.addEventListener('mouseup', () => { isDragging = false; });
  window.addEventListener('mousemove', (e) => {
    if(!isDragging) return;
    offsetX = offsetStart.x + (e.clientX - dragStart.x);
    offsetY = offsetStart.y + (e.clientY - dragStart.y);
    clampOffset();
    requestRedraw();
    // Update cell under mouse after pan
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const cell = pixelToCell(mouseX, mouseY);
    if(cell.x !== currentCell.x || cell.y !== currentCell.y) {
      currentCell = cell;
      updateCoordsDisplay(cell.x, cell.y);
      ensureCellVisible(cell.x, cell.y);
      requestRedraw();
    }
  });

  // Throttled mousemove for highlight and auto cell push
  canvas.addEventListener('mousemove', (e) => {
    if(isDragging) return;
    if (redrawPending) return;
    redrawPending = true;
    requestAnimationFrame(() => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const cell = pixelToCell(mouseX, mouseY);
      if(cell.x !== currentCell.x || cell.y !== currentCell.y) {
        currentCell = cell;
        updateCoordsDisplay(cell.x, cell.y);
        ensureCellVisible(cell.x, cell.y);
        drawGrid();
      }
      redrawPending = false;
    });
  });

  // Touch support for pan
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      touchStart = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY,
        offsetX,
        offsetY
      };
    }
  }, {passive:true});
  canvas.addEventListener('touchmove', (e) => {
    if (!touchStart || e.touches.length !== 1) return;
    const dx = e.touches[0].clientX - touchStart.x;
    const dy = e.touches[0].clientY - touchStart.y;
    offsetX = touchStart.offsetX + dx;
    offsetY = touchStart.offsetY + dy;
    clampOffset();
    requestRedraw();
  }, {passive:true});
  canvas.addEventListener('touchend', () => { touchStart = null; });

  // Keyboard navigation for pan and zoom
  frame.addEventListener('keydown', (e) => {
    const panStep = 30 * zoom;
    switch(e.key) {
      case 'ArrowLeft':
        offsetX += panStep;
        e.preventDefault(); break;
      case 'ArrowRight':
        offsetX -= panStep;
        e.preventDefault(); break;
      case 'ArrowUp':
        offsetY += panStep;
        e.preventDefault(); break;
      case 'ArrowDown':
        offsetY -= panStep;
        e.preventDefault(); break;
      case '+': case '=':
        setZoom(zoom * 1.1);
        e.preventDefault(); break;
      case '-':
        setZoom(zoom / 1.1);
        e.preventDefault(); break;
    }
    clampOffset();
    requestRedraw();
    // Center cell update
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    currentCell = pixelToCell(centerX, centerY);
    updateCoordsDisplay(currentCell.x, currentCell.y);
    ensureCellVisible(currentCell.x, currentCell.y);
  });

  // Donate button
  donateBtn.addEventListener('click', () => {
    alert('Thank you for your intention to donate! (Functionality to be implemented)');
    donateBtn.focus();
  });

  // Color selector
  colorSelect.addEventListener('change', (e) => {
    selectedColor = e.target.value;
    requestRedraw();
  });

  // Zoom buttons
  zoomInBtn.addEventListener('click', () => setZoom(zoom * 1.1));
  zoomOutBtn.addEventListener('click', () => setZoom(zoom / 1.1));

  // Canvas click for coloring cell and backend sync
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const cell = pixelToCell(mouseX, mouseY);
    if (
      cell.x >= 0 && cell.y >= 0 &&
      cell.x < GRID_SIZE && cell.y < GRID_SIZE
    ) {
      coloredCells[`${cell.x},${cell.y}`] = selectedColor;
      requestRedraw();
      sendCellColor(cell.x, cell.y, selectedColor);
    }
  });

  // Focus frame for keyboard input
  window.addEventListener('load', () => {
    setCanvasSize();
    frame.focus();
    offsetX = (canvas.width - GRID_SIZE * CELL_SIZE * zoom) / 2;
    offsetY = (canvas.height - GRID_SIZE * CELL_SIZE * zoom) / 2;
    clampOffset();
    drawGrid();
    zoomDisplay.textContent = Math.round(zoom * 100) + '%';
    fetchGridState();
  });
  window.addEventListener('resize', setCanvasSize);

  frame.addEventListener('click', () => { frame.focus(); });

})();
</script>
</body>
</html>
