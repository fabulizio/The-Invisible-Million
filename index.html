<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Invisible Million</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      max-width: 600px;
      padding: 1.5rem;
      text-align: center;
    }
    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      gap: 20px;
      margin-bottom: 30px;
    }
    #minimap-container, #mainframe {
      width: 100%;
      max-width: 400px;
      aspect-ratio: 1/1;
      position: relative;
      border: 3px solid white;
      background-color: #ddd;
      touch-action: none;
    }
    canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      cursor: grab;
      image-rendering: pixelated;
    }
    #viewport-box {
      position: absolute;
      border: 2px solid red;
      background: rgba(255,0,0,0.15);
      touch-action: none;
    }
    #colorModal {
      display: none;
      position: fixed;
      z-index: 9999;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      background:#222;
      padding:20px;
      border-radius:8px;
      color:#fff;
      text-align:center;
      max-width:90vw;
    }
    #colorModal input, #colorModal button {
      margin:5px;
    }
    #counter {
      font-size:1.2rem;
      margin-top:10px;
    }
  </style>
</head>
<body>
<header>
  <h1>The Invisible Million</h1>
  <p>Zoom, esplora e colora un quadrato sulla griglia invisibile da un milione di celle!</p>
  <div id="counter">Loading painted squares...</div>
</header>
<div id="container">
  <div id="minimap-container">
    <canvas id="minimap"></canvas>
    <div id="viewport-box"></div>
  </div>
  <div id="mainframe">
    <canvas id="mainCanvas"></canvas>
  </div>
</div>
<div id="colorModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <h2 id="modalTitle">Scegli un colore</h2>
  <input type="color" id="colorPicker" value="#ff0000" />
  <div>
    <button id="cancelBtn">Annulla</button>
    <button id="okBtn">OK</button>
  </div>
</div>
<script>
const BACKEND_URL = "https://155ca338-0e90-4f5a-88ec-b6163921baae-00-181dgn4pq10j7.janeway.replit.dev";
const GRID_SIZE = 1000;

const mainCanvas = document.getElementById('mainCanvas');
const minimap = document.getElementById('minimap');
const viewportBox = document.getElementById('viewport-box');
const counter = document.getElementById('counter');
const colorModal = document.getElementById('colorModal');
const colorPicker = document.getElementById('colorPicker');
const okBtn = document.getElementById('okBtn');
const cancelBtn = document.getElementById('cancelBtn');
const mainframe = document.getElementById('mainframe');

const ctx = mainCanvas.getContext('2d');
const miniCtx = minimap.getContext('2d');
ctx.imageSmoothingEnabled = miniCtx.imageSmoothingEnabled = false;

let gridData = {}, selectedSquare = null;

let zoom = parseFloat(localStorage.getItem("zoom")) || 5;
let offsetX = parseFloat(localStorage.getItem("offsetX")) || 0;
let offsetY = parseFloat(localStorage.getItem("offsetY")) || 0;

let canvasSize = 0, scaleFactor = GRID_SIZE;
function resizeAll(){
  const size = Math.min(window.innerWidth*0.9,400);
  [mainCanvas,minimap].forEach(c=>{
    c.width = c.height = size;
  });
  canvasSize = size;
  scaleFactor = GRID_SIZE/size;
  render();
}
window.addEventListener('resize',resizeAll);

function clamp(){
  const vs = Math.floor(canvasSize/zoom);
  offsetX = Math.min(Math.max(offsetX,0),GRID_SIZE-vs);
  offsetY = Math.min(Math.max(offsetY,0),GRID_SIZE-vs);
}

function draw(){
  // main grid
  ctx.clearRect(0,0,canvasSize,canvasSize);
  const ps = zoom; const vs = Math.floor(canvasSize/ps);
  clamp();
  ctx.fillStyle = "#ddd"; ctx.fillRect(0,0,canvasSize,canvasSize);
  ctx.strokeStyle = "#bbb"; ctx.lineWidth =1;
  ctx.beginPath();
  for(let i=0;i<=vs;i++){
    ctx.moveTo(i*ps,0); ctx.lineTo(i*ps,vs*ps);
    ctx.moveTo(0,i*ps); ctx.lineTo(vs*ps,i*ps);
  }
  ctx.stroke();
  for(let x=0;x<vs;x++) for(let y=0;y<vs;y++){
    const gx=Math.floor(offsetX)+x, gy=Math.floor(offsetY)+y;
    const k = `${gx},${gy}`;
    if(gridData[k]){
      ctx.fillStyle = gridData[k].color;
      ctx.fillRect(x*ps,y*ps,ps,ps);
      ctx.strokeStyle="#000"; ctx.lineWidth=1;
      ctx.strokeRect(x*ps,y*ps,ps,ps);
    }
  }
  if(selectedSquare){
    const sx = selectedSquare.x-offsetX, sy=selectedSquare.y-offsetY;
    if(sx>=0 && sy>=0 && sx<vs && sy<vs){
      ctx.strokeStyle="yellow"; ctx.lineWidth=3;
      ctx.strokeRect(sx*ps,sy*ps,ps,ps);
    }
  }

  // minimap
  miniCtx.clearRect(0,0,canvasSize,canvasSize);
  miniCtx.fillStyle="#ddd"; miniCtx.fillRect(0,0,canvasSize,canvasSize);
  for(const k in gridData){
    const [gx,gy] = k.split(',').map(Number);
    miniCtx.fillStyle=gridData[k].color;
    miniCtx.fillRect(gx/scaleFactor,gy/scaleFactor,1/scaleFactor,1/scaleFactor);
  }
  const boxSize = vs/scaleFactor;
  viewportBox.style.width = viewportBox.style.height = boxSize+"px";
  viewportBox.style.left = offsetX/scaleFactor+"px";
  viewportBox.style.top = offsetY/scaleFactor+"px";
}

function render(){
  localStorage.setItem("zoom",zoom);
  localStorage.setItem("offsetX",offsetX);
  localStorage.setItem("offsetY",offsetY);
  draw();
}

function openModal(x,y){
  selectedSquare={x,y};
  colorPicker.value = gridData[`${x},${y}`]?.color||"#ff0000";
  colorModal.style.display="block";
  colorPicker.focus();
}
function closeModal(){ colorModal.style.display="none"; selectedSquare=null }

function paint(x,y,c){
  fetch(`${BACKEND_URL}/paint`,{
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify({x,y,color:c})
  }).then(r=>r.json()).then(d=>{
    if(d.success){
      gridData[`${x},${y}`]={color:c};
      counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
      render(); closeModal();
    } else alert(d.error||"Errore");
  }).catch(()=>alert("Errore rete"));
}

// inizializza
fetch(`${BACKEND_URL}/painted`)
.then(r=>r.json()).then(d=>{
  gridData = d;
  counter.textContent = `Quadrati dipinti: ${Object.keys(gridData).length}`;
  resizeAll();
})
.catch(()=> counter.textContent="Errore caricamento");

// zoom wheel
mainCanvas.addEventListener('wheel',e=>{
  e.preventDefault();
  const mx = e.clientX-mainCanvas.getBoundingClientRect().left;
  const my = e.clientY-mainCanvas.getBoundingClientRect().top;
  const old=zoom;
  zoom=Math.min(20,Math.max(1,zoom+(e.deltaY>0?-0.5:0.5)));
  offsetX += mx/old-mx/zoom;
  offsetY += my/old-my/zoom;
  render();
},{passive:false});

// drag grid
let dragging=false, ds={x:0,y:0};
mainCanvas.addEventListener('mousedown',e=>{dragging=true; ds={x:e.clientX,y:e.clientY}})
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{
  if(dragging){
    offsetX += (ds.x - e.clientX)/zoom;
    offsetY += (ds.y - e.clientY)/zoom;
    ds={x:e.clientX,y:e.clientY};
    render();
  }
});

// click to paint
mainCanvas.addEventListener('click',e=>{
  const px=e.clientX-mainCanvas.getBoundingClientRect().left;
  const py=e.clientY-mainCanvas.getBoundingClientRect().top;
  const x=Math.floor(offsetX+px/zoom);
  const y=Math.floor(offsetY+py/zoom);
  if(!gridData[`${x},${y}`]) openModal(x,y);
});

// modal events
okBtn.addEventListener('click',()=>{ if(selectedSquare) paint(selectedSquare.x,selectedSquare.y,colorPicker.value)});
cancelBtn.addEventListener('click',closeModal);
window.addEventListener('keydown', e=>{ if(e.key==="Escape") closeModal() });

// pinch-to-zoom & double-tap fullscreen
let pinching=false, lastDist=0, lastTap=0;

mainframe.addEventListener('touchstart',e=>{
  if(e.touches.length===2){ pinching=true; lastDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY); }
  if(e.touches.length===1){
    const now=Date.now();
    if(now-lastTap<300) mainframe.requestFullscreen().catch(_=>{});
    lastTap=now;
  }
});
mainframe.addEventListener('touchmove',e=>{
  if(pinching&&e.touches.length===2){
    const d=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
    const delta=(d-lastDist)*0.02;
    const old=zoom;
    zoom=Math.min(20,Math.max(1,zoom+delta));
    offsetX += canvasSize/2/old - canvasSize/2/zoom;
    offsetY += canvasSize/2/old - canvasSize/2/zoom;
    lastDist=d; render();
  }
  e.preventDefault();
},{passive:false});
mainframe.addEventListener('touchend',()=>pinching=false);

// minimap click/drag to relocate viewport
let mvDrag=false;
minimap.addEventListener('mousedown',e=>{ mvDrag=true; });
window.addEventListener('mouseup',()=>mvDrag=false);
minimap.addEventListener('mousemove',e=>{
  if(mvDrag){
    const rect=minimap.getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const vs = Math.floor(canvasSize/zoom);
    offsetX = mx*scaleFactor - vs/2;
    offsetY = my*scaleFactor - vs/2;
    render();
  }
});
minimap.addEventListener('click',e=>{
  const rect=minimap.getBoundingClientRect();
  const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  const vs = Math.floor(canvasSize/zoom);
  offsetX = mx*scaleFactor - vs/2;
  offsetY = my*scaleFactor - vs/2;
  render();
});
</script>
</body>
</html>
