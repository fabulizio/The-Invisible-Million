<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>The Invisible Million</title>
<style>
  /* --- Reset e base --- */
  body, html {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  #container {
    display: flex; flex-direction: column; height: 100vh;
  }
  #mainGrid {
    flex: 1 1 auto;
    background: #222;
    position: relative;
    touch-action: none;
  }
  #minimap {
    flex: 0 0 150px;
    background: #111;
    border-top: 2px solid #444;
    position: relative;
  }
  canvas {
    display: block;
    background: #222;
    width: 100%; height: 100%;
  }
  #toolbar {
    background: #000;
    color: #eee;
    padding: 5px 10px;
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
    user-select: none;
  }
  #toolbar > * {
    font-size: 14px;
  }
  button, select, input[type=color] {
    background: #333;
    border: 1px solid #555;
    color: #eee;
    padding: 4px 8px;
    cursor: pointer;
    border-radius: 3px;
  }
  button:hover, select:hover, input[type=color]:hover {
    background: #555;
  }
  #tooltip {
    position: absolute;
    pointer-events: none;
    background: rgba(0,0,0,0.7);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    color: #ddd;
    white-space: nowrap;
    z-index: 1000;
    display: none;
  }
  #colorPreview {
    width: 22px; height: 22px;
    border: 1px solid #555;
    display: inline-block;
    vertical-align: middle;
  }
  @media (max-width: 600px) {
    #minimap {
      height: 100px;
    }
    #toolbar {
      font-size: 12px;
      gap: 6px;
    }
  }
</style>
</head>
<body>

<div id="container">
  <div id="toolbar">
    <label for="colorPicker" id="labelColor">Colore:</label>
    <input type="color" id="colorPicker" value="#ff0000" />
    <div id="colorPreview" title="Colore selezionato"></div>

    <button id="resetViewBtn" title="Reset zoom e posizione">Reset View</button>

    <label for="languageSelect" id="labelLang">Lingua:</label>
    <select id="languageSelect" aria-label="Seleziona lingua">
      <option value="it" selected>Italiano</option>
      <option value="en">English</option>
    </select>

    <span id="statusSync" style="margin-left:auto; font-weight: bold;">Offline</span>
  </div>

  <div id="mainGrid">
    <canvas id="gridCanvas" width="1000" height="1000" style="width:100%; height:100%;"></canvas>
    <div id="tooltip"></div>
  </div>

  <div id="minimap">
    <canvas id="miniCanvas" width="1000" height="150"></canvas>
  </div>
</div>

<script>
(() => {
  const LANGS = {
    it: {
      labelColor: "Colore:",
      resetView: "Reset View",
      labelLang: "Lingua:",
      offline: "Offline",
      online: "Online",
      squareTooltip: (x,y,color) => `Cella (${x}, ${y}) - Colore: ${color}`,
    },
    en: {
      labelColor: "Color:",
      resetView: "Reset View",
      labelLang: "Language:",
      offline: "Offline",
      online: "Online",
      squareTooltip: (x,y,color) => `Cell (${x}, ${y}) - Color: ${color}`,
    }
  };

  // Stato iniziale
  const state = {
    scale: 1,
    translateX: 0,
    translateY: 0,
    gridSize: 1000,
    cellSize: 20, // base cell size (zoom varierà)
    selectedColor: '#ff0000',
    paintedCells: {}, // key "x,y": color
    isPanning: false,
    lastPan: {x:0,y:0},
    lang: 'it',
  };

  // Canvas e contesti
  const gridCanvas = document.getElementById('gridCanvas');
  const gridCtx = gridCanvas.getContext('2d');
  const miniCanvas = document.getElementById('miniCanvas');
  const miniCtx = miniCanvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const colorPicker = document.getElementById('colorPicker');
  const colorPreview = document.getElementById('colorPreview');
  const resetViewBtn = document.getElementById('resetViewBtn');
  const languageSelect = document.getElementById('languageSelect');
  const statusSync = document.getElementById('statusSync');
  const labelColor = document.getElementById('labelColor');
  const labelLang = document.getElementById('labelLang');

  // Dimensioni minimappa
  const miniHeight = miniCanvas.height;
  const miniWidth = miniCanvas.width;

  // Local Storage keys
  const LS_KEYS = {
    zoom: 'invisibleMillion_zoom',
    translateX: 'invisibleMillion_translateX',
    translateY: 'invisibleMillion_translateY',
    paintedCells: 'invisibleMillion_paintedCells',
    lang: 'invisibleMillion_lang'
  };

  // --- Utilità ---
  function saveViewState(){
    localStorage.setItem(LS_KEYS.zoom, state.scale);
    localStorage.setItem(LS_KEYS.translateX, state.translateX);
    localStorage.setItem(LS_KEYS.translateY, state.translateY);
  }
  function loadViewState(){
    const zoom = parseFloat(localStorage.getItem(LS_KEYS.zoom));
    const tx = parseFloat(localStorage.getItem(LS_KEYS.translateX));
    const ty = parseFloat(localStorage.getItem(LS_KEYS.translateY));
    if (!isNaN(zoom)) state.scale = zoom;
    if (!isNaN(tx)) state.translateX = tx;
    if (!isNaN(ty)) state.translateY = ty;
  }
  function savePaintedCells(){
    // Salva in localStorage con compressione semplice JSON.stringify
    try {
      localStorage.setItem(LS_KEYS.paintedCells, JSON.stringify(state.paintedCells));
    } catch(e){
      console.warn("LocalStorage pieno o errore salvataggio celle");
    }
  }
  function loadPaintedCells(){
    try {
      const data = localStorage.getItem(LS_KEYS.paintedCells);
      if (data) {
        state.paintedCells = JSON.parse(data);
      }
    } catch(e){
      state.paintedCells = {};
    }
  }
  function saveLang(){
    localStorage.setItem(LS_KEYS.lang, state.lang);
  }
  function loadLang(){
    const l = localStorage.getItem(LS_KEYS.lang);
    if(l && LANGS[l]) state.lang = l;
  }

  // Sincronizzazione (mock WebSocket)
  let socket = null;
  function connectSocket(){
    try {
      socket = new WebSocket('wss://example.com/socket');
      socket.onopen = () => {
        statusSync.textContent = LANGS[state.lang].online;
        socket.send(JSON.stringify({type:"hello"}));
      };
      socket.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          if(msg.type === 'paint' && msg.cell && msg.color){
            state.paintedCells[msg.cell] = msg.color;
            drawGrid(); // Aggiorna solo la griglia
          }
        } catch {}
      };
      socket.onclose = () => {
        statusSync.textContent = LANGS[state.lang].offline;
        setTimeout(connectSocket, 3000);
      };
      socket.onerror = () => {
        statusSync.textContent = LANGS[state.lang].offline;
      };
    } catch {
      statusSync.textContent = LANGS[state.lang].offline;
    }
  }

  // Funzione per inviare aggiornamenti cella
  function sendPaint(cellKey,color){
    if(socket && socket.readyState === WebSocket.OPEN){
      socket.send(JSON.stringify({type:'paint', cell:cellKey, color}));
    }
  }

  // Cambio lingua
  function updateLanguage(){
    const texts = LANGS[state.lang];
    labelColor.textContent = texts.labelColor;
    resetViewBtn.textContent = texts.resetView;
    labelLang.textContent = texts.labelLang;
    statusSync.textContent = socket && socket.readyState === WebSocket.OPEN ? texts.online : texts.offline;
  }

  // Reset zoom e posizione
  function resetView(){
    state.scale = 1;
    state.translateX = 0;
    state.translateY = 0;
    saveViewState();
    drawGrid();
    drawMiniMap();
  }

  // --- Rendering ---

  // Calcolo celle visibili e disegno con requestAnimationFrame
  let drawRequestId = null;
  function drawGrid(){
    if(drawRequestId) return; // Evita chiamate multiple
    drawRequestId = requestAnimationFrame(() => {
      drawRequestId = null;

      const w = gridCanvas.width;
      const h = gridCanvas.height;
      gridCtx.setTransform(1,0,0,1,0,0);
      gridCtx.clearRect(0,0,w,h);

      // Trasformazione per zoom + pan
      gridCtx.translate(state.translateX, state.translateY);
      gridCtx.scale(state.scale, state.scale);

      const cellSize = state.cellSize;
      const gridSize = state.gridSize;

      // Calcola viewport visibile in coordinate grid
      const invScale = 1 / state.scale;
      const viewLeft = -state.translateX * invScale;
      const viewTop = -state.translateY * invScale;
      const viewRight = viewLeft + w * invScale;
      const viewBottom = viewTop + h * invScale;

      // Limita le coordinate alle celle visibili
      const startX = Math.max(0, Math.floor(viewLeft / cellSize));
      const startY = Math.max(0, Math.floor(viewTop / cellSize));
      const endX = Math.min(gridSize - 1, Math.ceil(viewRight / cellSize));
      const endY = Math.min(gridSize - 1, Math.ceil(viewBottom / cellSize));

      // Sfondo base
      gridCtx.fillStyle = '#222';
      gridCtx.fillRect(0,0,gridSize*cellSize, gridSize*cellSize);

      // Disegna celle dipinte
      for(let x=startX; x<=endX; x++){
        for(let y=startY; y<=endY; y++){
          const key = `${x},${y}`;
          if(state.paintedCells[key]){
            gridCtx.fillStyle = state.paintedCells[key];
            gridCtx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
          }
        }
      }
      // Griglia
      gridCtx.strokeStyle = 'rgba(100,100,100,0.1)';
      gridCtx.lineWidth = 1 / state.scale;
      gridCtx.beginPath();
      for(let x=startX; x<=endX; x++){
        const xpos = x * cellSize;
        gridCtx.moveTo(xpos, startY*cellSize);
        gridCtx.lineTo(xpos, (endY+1)*cellSize);
      }
      for(let y=startY; y<=endY; y++){
        const ypos = y * cellSize;
        gridCtx.moveTo(startX*cellSize, ypos);
        gridCtx.lineTo((endX+1)*cellSize, ypos);
      }
      gridCtx.stroke();
    });
  }

  // Disegna minimappa
  function drawMiniMap(){
    miniCtx.setTransform(1,0,0,1,0,0);
    miniCtx.clearRect(0,0,miniWidth, miniHeight);
    // Sfondo minimappa
    miniCtx.fillStyle = '#111';
    miniCtx.fillRect(0, 0, miniWidth, miniHeight);

    const scaleY = miniHeight / (state.gridSize * state.cellSize);
    const scaleX = miniWidth / (state.gridSize * state.cellSize);

    // Celle dipinte minimappa - pixel per cella
    const cellW = scaleX * state.cellSize;
    const cellH = scaleY * state.cellSize;

    // Per performance, disegna pixel per cella dipinta
    miniCtx.fillStyle = 'red';
    for(const key in state.paintedCells){
      const [x,y] = key.split(',').map(Number);
      miniCtx.fillStyle = state.paintedCells[key];
      miniCtx.fillRect(x*cellW, y*cellH, cellW, cellH);
    }

    // Rettangolo viewport rosso nella minimappa
    const viewLeft = -state.translateX / state.scale;
    const viewTop = -state.translateY / state.scale;
    const viewWidth = gridCanvas.width / state.scale;
    const viewHeight = gridCanvas.height / state.scale;

    miniCtx.strokeStyle = '#f00';
    miniCtx.lineWidth = 2;
    miniCtx.strokeRect(viewLeft * scaleX, viewTop * scaleY,
                       viewWidth * scaleX, viewHeight * scaleY);
  }

  // --- Interazioni ---

  // Conversione coordinate canvas -> cella grid
  function coordsToCell(x,y){
    const rect = gridCanvas.getBoundingClientRect();
    const canvasX = x - rect.left;
    const canvasY = y - rect.top;

    // Applica trasformazione inversa
    const invScale = 1 / state.scale;
    const gridX = (canvasX - state.translateX) * invScale;
    const gridY = (canvasY - state.translateY) * invScale;

    const cellX = Math.floor(gridX / state.cellSize);
    const cellY = Math.floor(gridY / state.cellSize);

    if(cellX < 0 || cellX >= state.gridSize || cellY < 0 || cellY >= state.gridSize){
      return null;
    }
    return {cellX, cellY};
  }

  // Gestione pittura cella
  function paintCell(x,y,color){
    if(x<0||x>=state.gridSize||y<0||y>=state.gridSize) return;
    const key = `${x},${y}`;
    state.paintedCells[key] = color;
    savePaintedCells();
    sendPaint(key,color);
    drawGrid();
    drawMiniMap();
  }

  // Tooltip aggiornamento
  function updateTooltip(mouseX, mouseY){
    const cell = coordsToCell(mouseX, mouseY);
    if(cell){
      const key = `${cell.cellX},${cell.cellY}`;
      const color = state.paintedCells[key] || 'nessuno';
      tooltip.style.display = 'block';
      tooltip.textContent = LANGS[state.lang].squareTooltip(cell.cellX, cell.cellY, color);
      tooltip.style.left = (mouseX + 15) + 'px';
      tooltip.style.top = (mouseY + 15) + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  }

  // Panning e zoom touch e mouse
  let lastTouchDistance = null;

  function distanceBetweenTouches(touches){
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  // Doppio tap timer
  let lastTapTime = 0;
  function handleDoubleTap(x,y){
    toggleFullScreen();
  }

  // Fullscreen toggle
  function toggleFullScreen(){
    if(!document.fullscreenElement){
      document.documentElement.requestFullscreen().catch(()=>{});
    } else {
      document.exitFullscreen().catch(()=>{});
    }
  }

  // Eventi
  function setupEvents(){
    // Mouse down -> pan start or paint
    gridCanvas.addEventListener('mousedown', e => {
      e.preventDefault();
      if(e.button !== 0) return; // Solo sinistro

      state.isPanning = true;
      state.lastPan.x = e.clientX;
      state.lastPan.y = e.clientY;
    });

    // Mouse move -> pan or tooltip
    gridCanvas.addEventListener('mousemove', e => {
      if(state.isPanning){
        const dx = e.clientX - state.lastPan.x;
        const dy = e.clientY - state.lastPan.y;
        state.translateX += dx;
        state.translateY += dy;
        state.lastPan.x = e.clientX;
        state.lastPan.y = e.clientY;
        saveViewState();
        drawGrid();
        drawMiniMap();
      }
      updateTooltip(e.clientX, e.clientY);
    });

    // Mouse up -> stop pan and paint cell
    gridCanvas.addEventListener('mouseup', e => {
      if(state.isPanning){
        state.isPanning = false;
      } else if(e.button === 0){
        const cell = coordsToCell(e.clientX, e.clientY);
        if(cell){
          paintCell(cell.cellX, cell.cellY, state.selectedColor);
    // Mouse up -> stop pan and paint cell
    gridCanvas.addEventListener('mouseup', e => {
      if(state.isPanning){
        state.isPanning = false;
      } else if(e.button === 0){
        const cell = coordsToCell(e.clientX, e.clientY);
        if(cell){
          paintCell(cell.cellX, cell.cellY, state.selectedColor);
        }
      }
    });

    // Mouse leave -> stop panning
    gridCanvas.addEventListener('mouseleave', e => {
      state.isPanning = false;
      tooltip.style.display = 'none';
    });

    // Wheel zoom centered on mouse pos
    gridCanvas.addEventListener('wheel', e => {
      e.preventDefault();
      const wheelDelta = -e.deltaY;
      const zoomFactor = 1 + (wheelDelta > 0 ? 0.1 : -0.1);
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      // Coordinate grid prima zoom
      const rect = gridCanvas.getBoundingClientRect();
      const cx = (mouseX - rect.left - state.translateX) / state.scale;
      const cy = (mouseY - rect.top - state.translateY) / state.scale;

      // Aggiorna zoom (limiti 0.5 - 10)
      let newScale = Math.min(10, Math.max(0.5, state.scale * zoomFactor));
      if(newScale === state.scale) return;

      // Adatta translate per mantenere il punto zoomato fisso
      state.translateX = mouseX - cx * newScale - rect.left;
      state.translateY = mouseY - cy * newScale - rect.top;
      state.scale = newScale;

      saveViewState();
      drawGrid();
      drawMiniMap();
    }, { passive: false });

    // Touch events per pan e pinch zoom
    gridCanvas.addEventListener('touchstart', e => {
      e.preventDefault();
      if(e.touches.length === 1){
        const touch = e.touches[0];
        const now = Date.now();
        if(now - lastTapTime < 300){
          handleDoubleTap(touch.clientX, touch.clientY);
          lastTapTime = 0;
          return;
        }
        lastTapTime = now;

        state.isPanning = true;
        state.lastPan.x = touch.clientX;
        state.lastPan.y = touch.clientY;
      } else if(e.touches.length === 2){
        state.isPanning = false;
        lastTouchDistance = distanceBetweenTouches(e.touches);
      }
    }, { passive: false });

    gridCanvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if(e.touches.length === 1 && state.isPanning){
        const touch = e.touches[0];
        const dx = touch.clientX - state.lastPan.x;
        const dy = touch.clientY - state.lastPan.y;
        state.translateX += dx;
        state.translateY += dy;
        state.lastPan.x = touch.clientX;
        state.lastPan.y = touch.clientY;
        saveViewState();
        drawGrid();
        drawMiniMap();
      } else if(e.touches.length === 2){
        const dist = distanceBetweenTouches(e.touches);
        if(lastTouchDistance){
          const zoomFactor = dist / lastTouchDistance;
          const newScale = Math.min(10, Math.max(0.5, state.scale * zoomFactor));
          if(newScale !== state.scale){
            // Centro pinch (media dei due tocchi)
            const rect = gridCanvas.getBoundingClientRect();
            const cx = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
            const cy = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;

            const gridCX = (cx - state.translateX) / state.scale;
            const gridCY = (cy - state.translateY) / state.scale;

            state.translateX = cx - gridCX * newScale;
            state.translateY = cy - gridCY * newScale;
            state.scale = newScale;

            saveViewState();
            drawGrid();
            drawMiniMap();
          }
        }
        lastTouchDistance = dist;
      }
    }, { passive: false });

    gridCanvas.addEventListener('touchend', e => {
      if(e.touches.length < 2){
        lastTouchDistance = null;
      }
      if(e.touches.length === 0){
        state.isPanning = false;
      }
    });

    // Click sulla minimappa per spostare viewport
    miniCanvas.addEventListener('click', e => {
      const rect = miniCanvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      // Converti posizione click in coordinate grid
      const scaleX = miniWidth / (state.gridSize * state.cellSize);
      const scaleY = miniHeight / (state.gridSize * state.cellSize);
      const gridX = clickX / scaleX;
      const gridY = clickY / scaleY;

      // Centra viewport sulla posizione cliccata
      const viewWidth = gridCanvas.width / state.scale;
      const viewHeight = gridCanvas.height / state.scale;

      state.translateX = -gridX + viewWidth / 2;
      state.translateY = -gridY + viewHeight / 2;

      saveViewState();
      drawGrid();
      drawMiniMap();
    });

    // Cambio colore selezionato
    colorPicker.addEventListener('input', e => {
      state.selectedColor = e.target.value;
      colorPreview.style.backgroundColor = state.selectedColor;
    });

    // Pulsante reset view
    resetViewBtn.addEventListener('click', () => {
      resetView();
    });

    // Cambio lingua
    languageSelect.addEventListener('change', e => {
      state.lang = e.target.value;
      updateLanguage();
      saveLang();
    });

    // Tastiera
    window.addEventListener('keydown', e => {
      // WASD o frecce per pan
      const panStep = 50;
      switch(e.key){
        case 'ArrowUp':
        case 'w':
        case 'W':
          state.translateY += panStep;
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          state.translateY -= panStep;
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          state.translateX += panStep;
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          state.translateX -= panStep;
          break;
        case '+':
        case '=':
          // Zoom in centro viewport
          zoomAt(gridCanvas.width/2, gridCanvas.height/2, 1.2);
          break;
        case '-':
        case '_':
          zoomAt(gridCanvas.width/2, gridCanvas.height/2, 1/1.2);
          break;
        case 'f':
        case 'F':
          toggleFullScreen();
          break;
        case 'r':
        case 'R':
          resetView();
          break;
      }
      saveViewState();
      drawGrid();
      drawMiniMap();
    });

  }

  // Funzione zoom con coordinate centro
  function zoomAt(cx, cy, zoomFactor){
    const rect = gridCanvas.getBoundingClientRect();
    const gridCX = (cx - state.translateX) / state.scale;
    const gridCY = (cy - state.translateY) / state.scale;

    let newScale = Math.min(10, Math.max(0.5, state.scale * zoomFactor));
    state.translateX = cx - gridCX * newScale;
    state.translateY = cy - gridCY * newScale;
    state.scale = newScale;
  }

  // --- Init ---
  function init(){
    loadViewState();
    loadPaintedCells();
    loadLang();
    colorPicker.value = state.selectedColor;
    colorPreview.style.backgroundColor = state.selectedColor;
    languageSelect.value = state.lang;
    updateLanguage();
    drawGrid();
    drawMiniMap();
    connectSocket();
    setupEvents();
  }

  window.onload = init;

})();
</script>

</body>
</html>
