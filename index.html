<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Invisible Million - Zoomable Grid with Minimap</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000;
    user-select: none; -webkit-user-select: none; -moz-user-select: none;
  }
  #container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    position: absolute;
    top: 0; left: 0;
    display: block;
  }
  #mainGrid {
    background-color: #111;
    width: 100vw;
    height: 100vh;
  }
  #minimap {
    width: 200px;
    height: 200px;
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    border: 2px solid #333;
    box-sizing: border-box;
    z-index: 10;
  }
  #instructions {
    position: absolute;
    bottom: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    font-size: 14px;
    background: rgba(0,0,0,0.5);
    padding: 8px 12px;
    border-radius: 8px;
    max-width: 300px;
    user-select: none;
  }
</style>
</head>
<body>
  <div id="container">
    <canvas id="mainGrid"></canvas>
    <canvas id="minimap" width="200" height="200"></canvas>
    <div id="instructions">
      Drag to pan, mouse wheel to zoom. Click minimap to jump viewport.
    </div>
  </div>

<script>
  (() => {
    const GRID_SIZE = 1000;   // grid is 1000 x 1000 cells
    const CELL_SIZE = 20;     // each cell 20px base size
    const MIN_ZOOM = 0.1;
    const MAX_ZOOM = 10;

    const canvas = document.getElementById('mainGrid');
    const ctx = canvas.getContext('2d');

    const minimap = document.getElementById('minimap');
    const miniCtx = minimap.getContext('2d');

    let width, height;

    // Viewport offset (in grid pixels) and zoom level
    let offsetX = 0;
    let offsetY = 0;
    let zoom = 1;

    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    // Resize main canvas to full viewport size
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      draw();
    }
    window.addEventListener('resize', resize);
    resize();

    // Draw the zoomable main grid
    function drawGrid() {
      ctx.clearRect(0, 0, width, height);

      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, width, height);

      // Calculate visible grid cell range
      const visibleCols = Math.ceil(width / (CELL_SIZE * zoom)) + 2;
      const visibleRows = Math.ceil(height / (CELL_SIZE * zoom)) + 2;

      const startCol = Math.floor(offsetX / CELL_SIZE);
      const startRow = Math.floor(offsetY / CELL_SIZE);

      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;

      // Draw grid cells as dark squares
      for (let row = startRow; row < startRow + visibleRows; row++) {
        if (row < 0 || row >= GRID_SIZE) continue;
        for (let col = startCol; col < startCol + visibleCols; col++) {
          if (col < 0 || col >= GRID_SIZE) continue;

          const x = (col * CELL_SIZE - offsetX) * zoom;
          const y = (row * CELL_SIZE - offsetY) * zoom;

          ctx.fillStyle = '#333';
          ctx.fillRect(x, y, CELL_SIZE * zoom, CELL_SIZE * zoom);

          // Optional: draw cell borders
          ctx.strokeRect(x, y, CELL_SIZE * zoom, CELL_SIZE * zoom);
        }
      }
    }

    // Draw the minimap
    function drawMinimap() {
      miniCtx.clearRect(0, 0, minimap.width, minimap.height);

      // Background
      miniCtx.fillStyle = '#ddd';
      miniCtx.fillRect(0, 0, minimap.width, minimap.height);

      // Grid fill
      miniCtx.fillStyle = '#999';
      miniCtx.fillRect(0, 0, minimap.width, minimap.height);

      // Calculate scale from grid to minimap
      const scale = minimap.width / (GRID_SIZE * CELL_SIZE);

      // Draw viewport rectangle in red
      miniCtx.strokeStyle = 'red';
      miniCtx.lineWidth = 2;

      // viewport in grid pixels:
      const viewportWidthInGridPx = width / zoom;
      const viewportHeightInGridPx = height / zoom;

      miniCtx.strokeRect(
        offsetX * scale,
        offsetY * scale,
        viewportWidthInGridPx * scale,
        viewportHeightInGridPx * scale
      );
    }

    // Main draw function
    function draw() {
      drawGrid();
      drawMinimap();
    }

    // Mouse dragging
    canvas.addEventListener('mousedown', e => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      canvas.style.cursor = 'grabbing';
    });

    window.addEventListener('mouseup', e => {
      isDragging = false;
      canvas.style.cursor = 'default';
    });

    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = (e.clientX - dragStartX) / zoom;
      const dy = (e.clientY - dragStartY) / zoom;

      offsetX -= dx;
      offsetY -= dy;

      // Clamp offset so we don't pan outside grid bounds
      offsetX = Math.min(Math.max(0, offsetX), GRID_SIZE * CELL_SIZE - width / zoom);
      offsetY = Math.min(Math.max(0, offsetY), GRID_SIZE * CELL_SIZE - height / zoom);

      dragStartX = e.clientX;
      dragStartY = e.clientY;

      draw();
    });

    // Zoom on wheel event
    canvas.addEventListener('wheel', e => {
      e.preventDefault();

      const mouseX = e.clientX;
      const mouseY = e.clientY;

      // Convert mouse pixel position to grid pixel coordinates before zoom
      const beforeZoomX = offsetX + mouseX / zoom;
      const beforeZoomY = offsetY + mouseY / zoom;

      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

      zoom *= zoomFactor;
      zoom = Math.min(Math.max(zoom, MIN_ZOOM), MAX_ZOOM);

      // Adjust offset so zoom is centered on mouse position
      offsetX = beforeZoomX - mouseX / zoom;
      offsetY = beforeZoomY - mouseY / zoom;

      // Clamp offset inside bounds
      offsetX = Math.min(Math.max(0, offsetX), GRID_SIZE * CELL_SIZE - width / zoom);
      offsetY = Math.min(Math.max(0, offsetY), GRID_SIZE * CELL_SIZE - height / zoom);

      draw();
    }, { passive: false });

    // Click minimap to reposition main viewport
    minimap.addEventListener('click', e => {
      const rect = minimap.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      const scale = minimap.width / (GRID_SIZE * CELL_SIZE);

      // Center viewport around clicked point
      const targetX = clickX / scale - width / (2 * zoom);
      const targetY = clickY / scale - height / (2 * zoom);

      offsetX = Math.min(Math.max(0, targetX), GRID_SIZE * CELL_SIZE - width / zoom);
      offsetY = Math.min(Math.max(0, targetY), GRID_SIZE * CELL_SIZE - height / zoom);

      draw();
    });

    // Initial draw
    draw();

  })();
</script>
</body>
</html>
